<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Serendipper-x</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://1979F.github.io/"/>
  <updated>2021-02-17T04:25:50.481Z</updated>
  <id>http://1979F.github.io/</id>
  
  <author>
    <name>XIAO_JING</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="http://1979F.github.io/2021/02/17/PyTorch%E4%B8%ADTensor%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95%E4%B8%8E%E5%8A%A8%E6%89%8B%E5%AD%A6%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%9A%84%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/"/>
    <id>http://1979F.github.io/2021/02/17/PyTorch中Tensor的基本用法与动手学深度学习的预备知识/</id>
    <published>2021-02-17T04:25:49.351Z</published>
    <updated>2021-02-17T04:25:50.481Z</updated>
    
    <content type="html"><![CDATA[<p>🐳🐳</p><ul><li><p>第一部分是PyTorch中有关Tensor的一些基本用法，因为之前并没有系统学习过PyTorch，所以现在看书的同时慢慢学习PyTorch的知识</p></li><li><p>第二部分是原书的知识和一些自己的理解</p></li></ul><p>@<a href>TOC</a></p><p><strong>张量 Tensor</strong> </p><p>张量包含了一个数据集合，这个数据集合就是原始值变形而来的，它可以是一个任何维度的数据。tensor的rank就是其维度。</p><a id="more"></a><p>Rank本意是矩阵的秩，不过Tensor Rank和Matrix Rank的意义不太一样，这里就还叫Rank。Tensor Rank的意义看起来更像是维度，比如Rank =1就是向量，Rank=2 就是矩阵了，Rank = 0 就是一个值。</p><h2 id="一、PyTorch-中的Tensor"><a href="#一、PyTorch-中的Tensor" class="headerlink" title="一、PyTorch 中的Tensor"></a>一、PyTorch 中的Tensor</h2><p>在PyTorch中，<strong><code>torch.Tensor</code></strong>是存储和变换数据的主要工具。<code>Tensor</code> 和 <code>NumPy</code> 的多维数组非常类似。</p><p>首先导入PyTorch</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br></pre></td></tr></table></figure><h3 id="1-1-Tensor的创建"><a href="#1-1-Tensor的创建" class="headerlink" title="1.1 Tensor的创建"></a>1.1 Tensor的创建</h3><p>创建一个5x3的未初始化的 <code>Tensor</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x = torch.empty(<span class="number">5</span>, <span class="number">3</span>)</span><br><span class="line">print(x)</span><br></pre></td></tr></table></figure><pre><code>tensor([[5.4880e+23, 4.5886e-41, 2.7434e-24],        [3.0915e-41, 4.4842e-44, 0.0000e+00],        [4.4842e-44, 0.0000e+00, 2.7450e-24],        [3.0915e-41, 5.4880e+23, 4.5886e-41],        [4.2039e-45, 0.0000e+00, 4.6243e-44]])</code></pre><p>创建一个5x3的随机初始化的 <code>Tensor</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x = torch.rand(<span class="number">5</span>, <span class="number">3</span>)  <span class="comment"># 这里rand的用法后面会讲到</span></span><br><span class="line">print(x)</span><br></pre></td></tr></table></figure><pre><code>tensor([[0.7787, 0.8019, 0.3431],        [0.1335, 0.3062, 0.2305],        [0.6151, 0.5777, 0.2794],        [0.4701, 0.6086, 0.9624],        [0.6524, 0.6794, 0.8206]])</code></pre><p>创建一个5x3的long类型全0的 <code>Tensor</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x = torch.zeros(<span class="number">5</span>, <span class="number">3</span>, dtype=torch.long)</span><br><span class="line">print(x)</span><br></pre></td></tr></table></figure><pre><code>tensor([[0, 0, 0],        [0, 0, 0],        [0, 0, 0],        [0, 0, 0],        [0, 0, 0]])</code></pre><p>直接根据数据创建</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x = torch.tensor([<span class="number">5.5</span>, <span class="number">3</span>])</span><br><span class="line">print(x)</span><br></pre></td></tr></table></figure><pre><code>tensor([5.5000, 3.0000])</code></pre><p>通过现有的 <code>Tensor</code> 来创建，此方法会默认重用输入 <code>Tensor</code> 的一些属性，例如数据类型，除非自定义数据类型。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x = x.new_ones(<span class="number">5</span>, <span class="number">3</span>, dtype=torch.float64)  <span class="comment"># new_ones 返回一个与size大小相同的用1填充的张量,默认具有相同的torch.dtype和torch.device</span></span><br><span class="line">print(x)</span><br><span class="line"></span><br><span class="line">x = torch.randn_like(x, dtype=torch.float) <span class="comment"># randn_like形状与输入的张量相同，指定新的数据类型</span></span><br><span class="line">print(x)</span><br></pre></td></tr></table></figure><pre><code>tensor([[1., 1., 1.],        [1., 1., 1.],        [1., 1., 1.],        [1., 1., 1.],        [1., 1., 1.]], dtype=torch.float64)tensor([[-0.9532,  0.4367, -0.1972],        [ 2.1078,  0.3750, -0.2939],        [-0.3682,  1.3246, -0.7197],        [-0.4119,  0.2093, -0.3431],        [-1.7094,  0.0638, -0.4597]])</code></pre><p>通过 <code>shape</code> 或者<code>size()</code> 来获取 <code>Tensor</code> 的形状</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(x.size())</span><br><span class="line">print(x.shape)</span><br></pre></td></tr></table></figure><pre><code>torch.Size([5, 3])torch.Size([5, 3])</code></pre><p>✨ 注意：返回的torch.Size其实就是一个tuple, 支持所有tuple的操作。</p><h3 id="1-2-Tensor的数据类型"><a href="#1-2-Tensor的数据类型" class="headerlink" title="1.2 Tensor的数据类型"></a>1.2 Tensor的数据类型</h3><h4 id="1-2-1-torch-FloatTensor"><a href="#1-2-1-torch-FloatTensor" class="headerlink" title="1.2.1  torch.FloatTensor"></a>1.2.1  torch.FloatTensor</h4><p>此变量用于生成数据类型为浮点型的 <code>Tensor</code>，传递给 <code>torch.FloatTensor</code> 的参数可以是一个列表，也可以是一个维度值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = torch.FloatTensor(<span class="number">2</span>, <span class="number">3</span>)  <span class="comment"># 两行三列</span></span><br><span class="line">print(a)</span><br></pre></td></tr></table></figure><pre><code>tensor([[5.4880e+23, 4.5886e-41, 5.4880e+23],        [4.5886e-41, 1.4584e-19, 7.8458e+17]])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">b = torch.FloatTensor([[<span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>]])</span><br><span class="line">print(b, b.shape, b.dtype)</span><br></pre></td></tr></table></figure><pre><code>tensor([[2., 3.],        [4., 5.]]) torch.Size([2, 2]) torch.float32</code></pre><h4 id="1-2-2-torch-IntTensor"><a href="#1-2-2-torch-IntTensor" class="headerlink" title="1.2.2 torch.IntTensor"></a>1.2.2 torch.IntTensor</h4><p>用于生成数据类型为整型的 <code>Tensor</code>，传递给 <code>torch.IntTensor</code> 的参数可以是一个列表，也可以是一个维度值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = torch.IntTensor(<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">print(a)</span><br></pre></td></tr></table></figure><pre><code>tensor([[1726508320,      32745,  407958368],        [     22062, 1953384789, 1701869908]], dtype=torch.int32)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">b = torch.IntTensor([[<span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>]])</span><br><span class="line">print(b, b.dtype)</span><br></pre></td></tr></table></figure><pre><code>tensor([[2, 3],        [4, 5]], dtype=torch.int32) torch.int32</code></pre><h4 id="1-2-3-torch-rand"><a href="#1-2-3-torch-rand" class="headerlink" title="1.2.3 torch.rand"></a>1.2.3 torch.rand</h4><p>用于生成数据类型为<strong>浮点型</strong>且维度指定的随机 <code>Tensor</code>，和在 <code>Numpy</code> 中使用 <code>numpy.rand</code> 生成随机数的方法类似，随机生成的浮点数据在 <strong>0~1区间均匀分布。</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = torch.rand(<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">print(a, a.dtype)</span><br></pre></td></tr></table></figure><pre><code>tensor([[0.8055, 0.3392, 0.5802],        [0.3333, 0.7156, 0.3415]]) torch.float32</code></pre><h4 id="1-2-4-torch-randn"><a href="#1-2-4-torch-randn" class="headerlink" title="1.2.4 torch.randn"></a>1.2.4 torch.randn</h4><p>用于生成数据类型为<strong>浮点型</strong>且维度指定的随机 <code>Tensor</code>，和在 <code>Numpy</code> 中使用 <code>numpy.randn</code>生成随机数的方法类似，随机生成的浮点数的取值满足<strong>均值为0，方差为1的正态分布</strong>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = torch.randn(<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">print(a, a.dtype)</span><br></pre></td></tr></table></figure><pre><code>tensor([[ 0.4737,  0.3686, -1.1102],        [ 0.9147, -0.3446, -0.7511]]) torch.float32</code></pre><h4 id="1-2-5-torch-range"><a href="#1-2-5-torch-range" class="headerlink" title="1.2.5 torch.range"></a>1.2.5 torch.range</h4><p>用于生成数据类型为<strong>浮点型</strong>且自定义其实范围和结束范围的 <code>Tensor</code>，所以传递给 <code>torch.range</code> 的参数有三个，分别是范围的<strong>起始值</strong>，范围的<strong>结束值</strong>和<strong>步长</strong>，其中，步长用于指定从起始值到结束值的每步的数据间隔。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = torch.range(<span class="number">2</span>, <span class="number">8</span>, <span class="number">3</span>)</span><br><span class="line">print(a, a.dtype)</span><br></pre></td></tr></table></figure><pre><code>tensor([2., 5., 8.]) torch.float32/opt/conda/lib/python3.7/site-packages/ipykernel_launcher.py:2: UserWarning: torch.range is deprecated in favor of torch.arange and will be removed in 0.5. Note that arange generates values in [start; end), not [start; end].</code></pre><h4 id="1-2-6-torch-zeros"><a href="#1-2-6-torch-zeros" class="headerlink" title="1.2.6 torch.zeros"></a>1.2.6 torch.zeros</h4><p>用于生成数据类型为<strong>浮点型</strong>且维度指定的 <code>Tensor</code>，不过这个浮点型的 <code>Tensor</code> 中的元素值全部为0</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = torch.zeros(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">print(a, a.dtype)</span><br></pre></td></tr></table></figure><pre><code>tensor([[0., 0., 0., 0.],        [0., 0., 0., 0.],        [0., 0., 0., 0.]]) torch.float32</code></pre><h3 id="1-3-Tensor的运算"><a href="#1-3-Tensor的运算" class="headerlink" title="1.3 Tensor的运算"></a>1.3 Tensor的运算</h3><p>这里通常对 <code>Tensor</code> 数据类型的变量进行运算，来组合一些简单或者复杂的算法，常用的 <code>Tensor</code> 运算如下：</p><h4 id="1-3-1-torch-abs"><a href="#1-3-1-torch-abs" class="headerlink" title="1.3.1 torch.abs"></a>1.3.1 torch.abs</h4><p>将参数传递到 <code>torch.abs</code> 后返回输入参数的绝对值作为输出，输出参数必须是一个 <code>Tensor</code> 数据类型的变量</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = torch.randn(<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">print(a)</span><br><span class="line">b = torch.abs(a)</span><br><span class="line">print(b)</span><br></pre></td></tr></table></figure><pre><code>tensor([[-1.5257,  0.1174, -0.2927],        [ 0.4662,  0.7019,  0.2605]])tensor([[1.5257, 0.1174, 0.2927],        [0.4662, 0.7019, 0.2605]])</code></pre><h4 id="1-3-2-torch-add"><a href="#1-3-2-torch-add" class="headerlink" title="1.3.2 torch.add"></a>1.3.2 torch.add</h4><p>将参数传递到 <code>torch.add</code> 后返回输入参数的求和结果作为输出，输入参数既可以全部是 <code>Tensor</code> 数据类型的变量，也可以是一个 <code>Tensor</code> 数据类型的变量，另一个是标量。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">a = torch.randn(<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">print(a)</span><br><span class="line"></span><br><span class="line">b = torch.randn(<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">print(b)</span><br><span class="line"></span><br><span class="line">c = torch.add(a, b)</span><br><span class="line">print(c)</span><br><span class="line"></span><br><span class="line">d = torch.randn(<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">print(d)</span><br><span class="line"></span><br><span class="line">e = torch.add(d, <span class="number">10</span>)</span><br><span class="line">print(e)</span><br></pre></td></tr></table></figure><pre><code>tensor([[-1.5090, -1.1659, -0.7795],        [ 0.8453, -0.0334,  0.2251]])tensor([[-1.5168, -1.2602,  0.8775],        [ 1.8206, -0.0880, -1.1371]])tensor([[-3.0258, -2.4261,  0.0980],        [ 2.6659, -0.1213, -0.9120]])tensor([[0.2818, 1.4852, 2.0287],        [1.1209, 1.6720, 1.0154]])tensor([[10.2818, 11.4852, 12.0287],        [11.1209, 11.6720, 11.0154]])</code></pre><p>可以指定输出</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">result = torch.empty(<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">torch.add(a, b, out=result)</span><br><span class="line">print(result)</span><br></pre></td></tr></table></figure><pre><code>tensor([[-3.0258, -2.4261,  0.0980],        [ 2.6659, -0.1213, -0.9120]])</code></pre><p>关于加法还有两种方式：</p><ul><li>第一种，+号</li><li>第二种，inplace</li></ul><p>✨ 注：PyTorch操作inplace版本都有后缀<em>, 例如x.copy</em>(y), x.t_()</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(a+b)</span><br></pre></td></tr></table></figure><pre><code>tensor([[-3.0258, -2.4261,  0.0980],        [ 2.6659, -0.1213, -0.9120]])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">b.add_(a)</span><br><span class="line">print(b)</span><br></pre></td></tr></table></figure><pre><code>tensor([[-3.0258, -2.4261,  0.0980],        [ 2.6659, -0.1213, -0.9120]])</code></pre><h4 id="1-3-3-torch-clamp"><a href="#1-3-3-torch-clamp" class="headerlink" title="1.3.3 torch.clamp"></a>1.3.3 torch.clamp</h4><p>　　<br>       对输入参数按照自定义的范围进行裁剪，最后将参数裁剪的结果作为输出。所以输入参数一共有三个，分别是需要进行裁剪的<strong>Tensor数据类型的变量</strong>、<strong>裁剪的上边界</strong>和<strong>裁剪的下边界</strong>，</p><p>具体的裁剪过程是：使用变量中的每个元素分别和裁剪的上边界及裁剪的下边界的值进行比较，如果元素的值小于裁剪的下边界的值，该元素就被重写成裁剪的下边界的值；</p><p>同理，如果元素的值大于裁剪的上边界的值，该元素就被重写成裁剪的上边界的值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a = torch.randn(<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">print(a)</span><br><span class="line"></span><br><span class="line">b = torch.clamp(a, <span class="number">-0.1</span>, <span class="number">0.1</span>)</span><br><span class="line">print(b)</span><br></pre></td></tr></table></figure><pre><code>tensor([[ 0.5965,  2.1073, -1.2866],        [-0.1101, -1.6736, -2.2357]])tensor([[ 0.1000,  0.1000, -0.1000],        [-0.1000, -0.1000, -0.1000]])</code></pre><h4 id="1-3-4-torch-div"><a href="#1-3-4-torch-div" class="headerlink" title="1.3.4 torch.div"></a>1.3.4 torch.div</h4><p>将参数传递到 <code>torch.div</code> 后返回输入参数的求商结果作为输出，同样，参与运算的参数可以全部是 <code>Tensor</code> 数据类型的变量，也可以是 <code>Tensor</code> 数据类型的变量和标量的组合。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">a = torch.randn(<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">print(a)</span><br><span class="line"> </span><br><span class="line">b = torch.randn(<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">print(b)</span><br><span class="line"> </span><br><span class="line">c = torch.div(a,b)</span><br><span class="line">print(c)</span><br><span class="line"> </span><br><span class="line">d = torch.randn(<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">print(d)</span><br><span class="line"> </span><br><span class="line">e = torch.div(d,<span class="number">10</span>)</span><br><span class="line">print(e)</span><br></pre></td></tr></table></figure><pre><code>tensor([[ 0.4518,  0.1334,  1.7579],        [ 0.0349, -0.2346,  1.6790]])tensor([[ 1.2516, -1.1198,  1.1351],        [-0.6222, -0.6472, -0.0758]])tensor([[  0.3610,  -0.1191,   1.5486],        [ -0.0561,   0.3624, -22.1492]])tensor([[ 0.2908,  0.0664, -1.4821],        [ 0.4358,  0.3226,  1.0338]])tensor([[ 0.0291,  0.0066, -0.1482],        [ 0.0436,  0.0323,  0.1034]])</code></pre><h4 id="1-3-5-torch-mul"><a href="#1-3-5-torch-mul" class="headerlink" title="1.3.5 torch.mul"></a>1.3.5 torch.mul</h4><p>将参数传递到 <code>torch.mul</code> 后返回输入参数求积的结果作为输出，参与运算的参数可以全部是 <code>Tensor</code> 数据类型的变量，也可以是 <code>Tensor</code> 数据类型的变量和标量的组合。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">a = torch.randn(<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">print(a)</span><br><span class="line"></span><br><span class="line">b = torch.randn(<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">print(b)</span><br><span class="line"></span><br><span class="line">c = torch.mul(a, b)</span><br><span class="line">print(c)</span><br><span class="line"></span><br><span class="line">d = torch.randn(<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">print(d)</span><br><span class="line"></span><br><span class="line">e = torch.mul(d, <span class="number">10</span>)</span><br><span class="line">print(e)</span><br></pre></td></tr></table></figure><pre><code>tensor([[ 0.5851,  0.2113,  0.6891],        [ 1.1177, -0.0177,  1.5595]])tensor([[ 0.9094, -0.0707, -0.3900],        [ 0.2990, -0.9827,  0.7165]])tensor([[ 0.5321, -0.0149, -0.2687],        [ 0.3342,  0.0174,  1.1174]])tensor([[-0.7012,  1.2348,  1.6156],        [ 0.5412,  0.2345, -0.5753]])tensor([[-7.0115, 12.3478, 16.1558],        [ 5.4116,  2.3447, -5.7526]])</code></pre><h4 id="1-3-6-torch-pow"><a href="#1-3-6-torch-pow" class="headerlink" title="1.3.6 torch.pow"></a>1.3.6 torch.pow</h4><p>将参数传递到 <code>torch.pow</code> 后返回输入参数的求幂结果作为输出，参与运算的参数可以全部是 <code>Tensor</code> 数据类型的变量，也可以是 <code>Tensor</code> 数据类型的变量和标量的组合。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a = torch.randn(<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">print(a)</span><br><span class="line"></span><br><span class="line">b = torch.pow(a, <span class="number">2</span>)</span><br><span class="line">print(b)</span><br></pre></td></tr></table></figure><pre><code>tensor([[-0.9387,  1.0499, -1.6718],        [-0.3190, -1.1677, -0.0666]])tensor([[0.8812, 1.1024, 2.7948],        [0.1018, 1.3635, 0.0044]])</code></pre><h4 id="1-3-7-torch-mm"><a href="#1-3-7-torch-mm" class="headerlink" title="1.3.7 torch.mm"></a>1.3.7 torch.mm</h4><p>将参数传递到 <code>torch.mm</code> 后返回输入参数的求积结果作为输出，不过这个求积的方式和之前的 <code>torch.mul</code>运算方式不太样，</p><p><code>torch.mm</code> 运用矩阵之间的乘法规则进行计算，所以被传入的参数会被当作矩阵进行处理，参数的维度自然也要满足矩阵乘法的前提条件，</p><p>即<strong>前一个矩阵的行数必须和后一个矩阵的列数相等</strong>，否则不能进行计算。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">a = torch.randn(<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">print(a)</span><br><span class="line"></span><br><span class="line">b = torch.randn(<span class="number">3</span>, <span class="number">2</span>)</span><br><span class="line">print(b)</span><br><span class="line"></span><br><span class="line">b = torch.mm(a, b)</span><br><span class="line">print(b)</span><br></pre></td></tr></table></figure><pre><code>tensor([[ 0.1701,  0.9539, -0.3128],        [-0.2466,  2.4600, -1.6023]])tensor([[-1.0573, -1.0292],        [-0.2707,  0.2992],        [-1.0913, -3.1058]])tensor([[-0.0967,  1.0818],        [ 1.3436,  5.9664]])</code></pre><h4 id="1-3-8-torch-mv"><a href="#1-3-8-torch-mv" class="headerlink" title="1.3.8 torch.mv"></a>1.3.8 torch.mv</h4><p>将参数传递到 <code>torch.mv</code> 后返回输入参数的求积结果作为输出，<code>torch.mv</code> 运用矩阵与向量之间的乘法规则进行计算，被传入的参数中的第1个参数代表矩阵，第2个参数代表向量，顺序不能颠倒。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">a = torch.randn(<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">print(a)</span><br><span class="line"></span><br><span class="line">b = torch.randn(<span class="number">3</span>)</span><br><span class="line">print(b)</span><br><span class="line"></span><br><span class="line">c = torch.mv(a, b)</span><br><span class="line">print(c)</span><br></pre></td></tr></table></figure><pre><code>tensor([[ 1.7745,  0.8665, -0.5622],        [-0.6072,  0.5540, -1.0647]])tensor([ 0.0553, -0.5526, -1.0924])tensor([0.2335, 0.8233])</code></pre><h2 id="二、原书"><a href="#二、原书" class="headerlink" title="二、原书"></a>二、原书</h2><h3 id="2-1-数据操作"><a href="#2-1-数据操作" class="headerlink" title="2.1 数据操作"></a>2.1 数据操作</h3><p> 部分操作已经在前面提及</p><h4 id="2-1-1-索引"><a href="#2-1-1-索引" class="headerlink" title="2.1.1 索引"></a>2.1.1 索引</h4><p>索引出来的结果与原数据共享内存，也即修改一个，另一个会跟着修改。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">x = torch.randn(<span class="number">2</span>, <span class="number">4</span>)</span><br><span class="line">print(x)</span><br><span class="line">y = x[:, :<span class="number">3</span>]</span><br><span class="line">print(y)</span><br><span class="line">y += <span class="number">1</span></span><br><span class="line">print(y)</span><br><span class="line">print(x[:, :<span class="number">3</span>]) <span class="comment"># 源tensor也被改了</span></span><br><span class="line">print(x)</span><br></pre></td></tr></table></figure><pre><code>tensor([[ 0.5706,  0.3683,  1.4869,  1.2791],        [-0.1592, -1.7226, -1.1192, -0.9729]])tensor([[ 0.5706,  0.3683,  1.4869],        [-0.1592, -1.7226, -1.1192]])tensor([[ 1.5706,  1.3683,  2.4869],        [ 0.8408, -0.7226, -0.1192]])tensor([[ 1.5706,  1.3683,  2.4869],        [ 0.8408, -0.7226, -0.1192]])tensor([[ 1.5706,  1.3683,  2.4869,  1.2791],        [ 0.8408, -0.7226, -0.1192, -0.9729]])</code></pre><p>除了常用的索引选择数据之外，PyTorch还提供了一些高级的选择函数:</p><table><thead><tr><th align="left">函数</th><th align="center">功能</th></tr></thead><tbody><tr><td align="left">index_select(input, dim, index)</td><td align="center">在指定维度dim上选取，比如选取某些行、某些列</td></tr><tr><td align="left">masked_select(input, mask,out=None)</td><td align="center">根据布尔掩码 (boolean mask) 索引输入张量的 1D 张量</td></tr><tr><td align="left">nonzero(input)</td><td align="center">非0元素的下标</td></tr><tr><td align="left">gather(input, dim, index)</td><td align="center">根据index，在dim维度上选取数据，输出的size与index一样</td></tr></tbody></table><p><strong>index_select</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">index_select(</span><br><span class="line">    input,</span><br><span class="line">    dim,</span><br><span class="line">    index</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>参数：</p><ul><li>input：索引的对象</li><li>dim：表示从第几维挑选数据，类型为int值；<strong>0表示按行索引，1表示按列索引</strong></li><li>index：表示从第一个参数维度中的哪个位置挑选数据，类型为torch.Tensor类的实例；</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(torch.index_select(x,<span class="number">0</span>,torch.tensor([<span class="number">0</span>, <span class="number">1</span>])))</span><br><span class="line">print(torch.index_select(x,<span class="number">1</span>,torch.tensor([<span class="number">0</span>, <span class="number">1</span>])))</span><br></pre></td></tr></table></figure><pre><code>tensor([[ 1.5706,  1.3683,  2.4869,  1.2791],        [ 0.8408, -0.7226, -0.1192, -0.9729]])tensor([[ 1.5706,  1.3683],        [ 0.8408, -0.7226]])</code></pre><p><strong>masked_select</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">masked_select(</span><br><span class="line">    input,</span><br><span class="line">    mask,</span><br><span class="line">    out</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>参数：</p><ul><li>input(Tensor) ：需要进行索引操作的输入张量；</li><li>mask(BoolTensor) ：要进行索引的布尔掩码</li><li>out(Tensor, optional) ：指定输出的张量。比如执行 torch.zeros([2, 2], out = tensor_a)，相当于执行 tensor_a = torch.zeros([2, 2])；</li></ul><p>⚠️ <strong>注意：「</strong> masked_select 函数最关键的参数就是布尔掩码 mask，</p><p>传入 mask 参数的布尔张量通过 True 和 False (或 1 和 0) 来决定输入张量对应位置的元素是否保留，</p><p>既然是一一对应的关系，这就需要传入 mask 中的布尔张量和传入 input 中的输入张量形状要相同。<strong>」</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mask = x.ge(<span class="number">0.5</span>)</span><br><span class="line">print(mask)</span><br><span class="line">print(torch.masked_select(x, mask))</span><br></pre></td></tr></table></figure><pre><code>tensor([[ True,  True,  True,  True],        [ True, False, False, False]])tensor([1.5706, 1.3683, 2.4869, 1.2791, 0.8408])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(x)</span><br><span class="line">print(torch.nonzero(x))</span><br></pre></td></tr></table></figure><pre><code>tensor([[ 1.5706,  1.3683,  2.4869,  1.2791],        [ 0.8408, -0.7226, -0.1192, -0.9729]])tensor([[0, 0],        [0, 1],        [0, 2],        [0, 3],        [1, 0],        [1, 1],        [1, 2],        [1, 3]])</code></pre><p><strong>gather</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">gather(</span><br><span class="line">    input, </span><br><span class="line">    dim,</span><br><span class="line">    index</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>参数：</p><ul><li>input (Tensor) – 需要进行索引操作的输入张量；</li><li>dim (int) – 表示从第几维挑选数据，类型为int值；</li><li>index (LongTensor) – 要收集的元素的索引；</li><li>out (Tensor, optional) – 指定输出的张量。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(torch.gather(x, dim=<span class="number">1</span>, index=torch.LongTensor([[<span class="number">0</span>, <span class="number">1</span>],[<span class="number">0</span>, <span class="number">0</span>]])))  <span class="comment"># dim为1说明按列索引，[0, 1]表示第一行的第0列和第1列，就是1.5706和1.3683，同理[0, 0]是0.8408和0.8408</span></span><br><span class="line">print(torch.gather(x, dim=<span class="number">0</span>, index=torch.LongTensor([[<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>]])))   <span class="comment"># dim为0说明按行索引，[0, 1, 1, 0]表示第0行，第1行，第1行，第0行</span></span><br></pre></td></tr></table></figure><pre><code>tensor([[1.5706, 1.3683],        [0.8408, 0.8408]])tensor([[ 1.5706, -0.7226, -0.1192,  1.2791],        [ 1.5706,  1.3683,  2.4869,  1.2791]])</code></pre><h4 id="2-1-2-改变形状"><a href="#2-1-2-改变形状" class="headerlink" title="2.1.2 改变形状"></a>2.1.2 改变形状</h4><p>用 <code>view()</code> 来改变 <code>Tensor</code> 的形状：</p><p>⚠️ 需要注意的是：-1所指的维度可以根据其他维度的值推出来，这个用法在很多地方都见过，应该要记住</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">y = x.view(<span class="number">8</span>)</span><br><span class="line">z = x.view(<span class="number">-1</span>, <span class="number">2</span>)  <span class="comment"># -1所指的维度可以根据其他维度的值推出来</span></span><br><span class="line">print(x.size(), y.size(), z.size())</span><br></pre></td></tr></table></figure><pre><code>torch.Size([2, 4]) torch.Size([8]) torch.Size([4, 2])</code></pre><p>🔥 <code>view()</code>返回的新 <code>Tensor</code> 与源 <code>Tensor</code> 虽然可能有不同的 <code>size</code>，但是是共享 <code>data</code> 的，也即更改其中的一个，另外一个也会跟着改变。(顾名思义，<code>view</code> 仅仅是改变了对这个张量的观察角度，内部数据并未改变)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x += <span class="number">1</span></span><br><span class="line">print(x)</span><br><span class="line">print(y)</span><br></pre></td></tr></table></figure><pre><code>tensor([[2.5706, 2.3683, 3.4869, 2.2791],        [1.8408, 0.2774, 0.8808, 0.0271]])tensor([2.5706, 2.3683, 3.4869, 2.2791, 1.8408, 0.2774, 0.8808, 0.0271])</code></pre><p>所以如果我们想返回一个真正新的副本（即不共享data内存）该怎么办呢？</p><p>Pytorch还提供了一个 <code>reshape()</code> 可以改变形状，但是此函数并不能保证返回的是其拷贝，所以不推荐使用。推荐先用 <code>clone</code> 创造一个副本然后再使用 <code>view</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x_cp = x.clone().view(<span class="number">8</span>)</span><br><span class="line">x -= <span class="number">1</span></span><br><span class="line">print(x)</span><br><span class="line">print(x_cp)</span><br></pre></td></tr></table></figure><pre><code>tensor([[ 1.5706,  1.3683,  2.4869,  1.2791],        [ 0.8408, -0.7226, -0.1192, -0.9729]])tensor([2.5706, 2.3683, 3.4869, 2.2791, 1.8408, 0.2774, 0.8808, 0.0271])</code></pre><p>✨ 使用 <code>clone</code> 还有一个好处是会被记录在计算图中，即梯度回传到副本时也会传到源 <code>Tensor</code></p><p>另外一个常用的函数就是 <code>item()</code>, 它可以将一个标量 <code>Tensor</code> 转换成一个Python number：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x = torch.randn(<span class="number">1</span>)</span><br><span class="line">print(x)</span><br><span class="line">print(x.item())</span><br></pre></td></tr></table></figure><pre><code>tensor([1.0600])1.059958815574646</code></pre><h3 id="2-2-线性代数"><a href="#2-2-线性代数" class="headerlink" title="2.2 线性代数"></a>2.2 线性代数</h3><p>另外，PyTorch还支持一些线性函数，这里提一下，免得用起来的时候自己造轮子，具体用法参考官方文档。如下表所示：</p><table><thead><tr><th align="left">函数</th><th align="center">功能</th></tr></thead><tbody><tr><td align="left">trace</td><td align="center">对角线元素之和(矩阵的迹)</td></tr><tr><td align="left">diag</td><td align="center">对角线元素</td></tr><tr><td align="left">triu/tril</td><td align="center">矩阵的上三角/下三角，可指定偏移量</td></tr><tr><td align="left">mm/bmm</td><td align="center">矩阵乘法，batch的矩阵乘法</td></tr><tr><td align="left">addmm/addbmm/addmv/addr/baddbmm..</td><td align="center">矩阵运算</td></tr><tr><td align="left">t</td><td align="center">转置</td></tr><tr><td align="left">dot/cross</td><td align="center">内积/外积</td></tr><tr><td align="left">inverse</td><td align="center">求逆矩阵</td></tr><tr><td align="left">svd</td><td align="center">奇异值分解</td></tr></tbody></table><h3 id="2-3-广播机制"><a href="#2-3-广播机制" class="headerlink" title="2.3 广播机制"></a>2.3 广播机制</h3><p>当对两个形状不同的 <code>Tensor</code> 按元素运算时，可能会触发广播（broadcasting）机制：先适当复制元素使这两个 <code>Tensor</code> 形状相同后再按元素运算。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x = torch.arange(<span class="number">1</span>, <span class="number">3</span>).view(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">print(x)</span><br><span class="line">y = torch.arange(<span class="number">1</span>, <span class="number">4</span>).view(<span class="number">3</span>, <span class="number">1</span>)</span><br><span class="line">print(y)</span><br><span class="line">print(x + y)</span><br></pre></td></tr></table></figure><pre><code>tensor([[1, 2]])tensor([[1],        [2],        [3]])tensor([[2, 3],        [3, 4],        [4, 5]])</code></pre><p>由于 <code>x</code> 和 <code>y</code> 分别是1行2列和3行1列的矩阵，如果要计算 <code>x + y</code>，那么 <code>x</code> 中第一行的2个元素被广播（复制）到了第二行和第三行，</p><p>而 <code>y</code> 中第一列的3个元素被广播（复制）到了第二列。如此，就可以对2个3行2列的矩阵按元素相加。</p><h3 id="2-4-运算内存开销"><a href="#2-4-运算内存开销" class="headerlink" title="2.4 运算内存开销"></a>2.4 运算内存开销</h3><p>前面说了，索引操作是不会开辟新内存的，而像<code>y = x + y</code> 这样的运算是会新开内存的，然后将y指向新内存。</p><p>为了演示这一点，我们可以使用Python自带的 <code>id</code> 函数：如果两个实例的ID一致，那么它们所对应的内存地址相同；反之则不同。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x = torch.tensor([<span class="number">1</span>, <span class="number">2</span>])</span><br><span class="line">y = torch.tensor([<span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line">id_before = id(y)</span><br><span class="line">y = y + x</span><br><span class="line">print(id(y) == id_before) <span class="comment"># False</span></span><br></pre></td></tr></table></figure><pre><code>False</code></pre><p>如果想指定结果到原来的 <code>y</code> 的内存，我们可以使用前面介绍的索引来进行替换操作。在下面的例子中，我们把<code>x + y</code>的结果通过 <code>[:]</code> 写进 <code>y</code> 对应的内存中。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x = torch.tensor([<span class="number">1</span>, <span class="number">2</span>])</span><br><span class="line">y = torch.tensor([<span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line">id_before = id(y)</span><br><span class="line">y[:] = y + x</span><br><span class="line">print(id(y) == id_before) <span class="comment"># True</span></span><br></pre></td></tr></table></figure><pre><code>True</code></pre><p>我们还可以使用运算符全名函数中的 <code>out</code> 参数或者自加运算符 <code>+=</code> (也即 <code>add_()</code> )达到上述效果，例如 <code>torch.add(x, y, out=y)</code>和 <code>y += x(y.add_(x))</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x = torch.tensor([<span class="number">1</span>, <span class="number">2</span>])</span><br><span class="line">y = torch.tensor([<span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line">id_before = id(y)</span><br><span class="line">torch.add(x, y, out=y) <span class="comment"># y += x, y.add_(x)</span></span><br><span class="line">print(id(y) == id_before) <span class="comment"># True</span></span><br></pre></td></tr></table></figure><pre><code>True</code></pre><p>✨ 注：虽然 <code>view</code> 返回的 <code>Tensor</code> 与源 <code>Tensor</code> 是共享data的，但是依然是一个新的 <code>Tensor</code>（因为 <code>Tensor</code> 除了包含data外还有一些其他属性），二者id（内存地址）并不一致。</p><h3 id="2-5-Tensor和NumPy相互转换"><a href="#2-5-Tensor和NumPy相互转换" class="headerlink" title="2.5 Tensor和NumPy相互转换"></a>2.5 Tensor和NumPy相互转换</h3><p>我们很容易用 <code>numpy()</code> 和 <code>from_numpy()</code> 将 <code>Tensor</code> 和 <code>NumPy</code> 中的数组相互转换。</p><p>但是需要注意的一点是： <strong>这两个函数所产生的的 <code>Tensor</code> 和 <code>NumPy</code> 中的数组共享相同的内存（所以他们之间的转换很快），改变其中一个时另一个也会改变！！！</strong></p><p>✨ <strong>还有一个常用的将NumPy中的array转换成Tensor的方法就是torch.tensor(), 需要注意的是，此方法总是会进行数据拷贝（就会消耗更多的时间和空间），所以返回的Tensor和原来的数据不再共享内存。</strong></p><p><strong>Tensor转NumPy</strong></p><p>使用 <code>numpy()</code>将 <code>Tensor</code> 转换成 <code>NumPy</code> 数组:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">a = torch.ones(<span class="number">5</span>)</span><br><span class="line">b = a.numpy()</span><br><span class="line">print(a, b)</span><br><span class="line"></span><br><span class="line">a += <span class="number">1</span></span><br><span class="line">print(a, b)</span><br><span class="line">b += <span class="number">1</span></span><br><span class="line">print(a, b)</span><br></pre></td></tr></table></figure><pre><code>tensor([1., 1., 1., 1., 1.]) [1. 1. 1. 1. 1.]tensor([2., 2., 2., 2., 2.]) [2. 2. 2. 2. 2.]tensor([3., 3., 3., 3., 3.]) [3. 3. 3. 3. 3.]</code></pre><p><strong>NumPy数组转Tensor</strong></p><p>使用<code>from_numpy()</code> 将 <code>NumPy</code> 数组转换成 <code>Tensor</code> :</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">a = np.ones(<span class="number">5</span>)</span><br><span class="line">b = torch.from_numpy(a)</span><br><span class="line">print(a, b)</span><br><span class="line"></span><br><span class="line">a += <span class="number">1</span></span><br><span class="line">print(a, b)</span><br><span class="line">b += <span class="number">1</span></span><br><span class="line">print(a, b)</span><br></pre></td></tr></table></figure><pre><code>[1. 1. 1. 1. 1.] tensor([1., 1., 1., 1., 1.], dtype=torch.float64)[2. 2. 2. 2. 2.] tensor([2., 2., 2., 2., 2.], dtype=torch.float64)[3. 3. 3. 3. 3.] tensor([3., 3., 3., 3., 3.], dtype=torch.float64)</code></pre><p>所有在CPU上的 <code>Tensor</code>（除了 <code>CharTensor</code>）都支持与 <code>NumPy</code> 数组相互转换。</p><p>此外上面提到还有一个常用的方法就是直接用 <code>torch.tensor()</code>将 <code>NumPy</code> 数组转换成 <code>Tensor</code>，</p><p>需要注意的是该方法总是会进行数据拷贝，返回的 <code>Tensor</code> 和原来的数据不再共享内存。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">c = torch.tensor(a)</span><br><span class="line">a += <span class="number">1</span></span><br><span class="line">print(a, c)</span><br></pre></td></tr></table></figure><pre><code>[4. 4. 4. 4. 4.] tensor([3., 3., 3., 3., 3.], dtype=torch.float64)</code></pre><h3 id="2-2-6-Tensor-on-GPU"><a href="#2-2-6-Tensor-on-GPU" class="headerlink" title="2.2.6 Tensor on GPU"></a>2.2.6 Tensor on GPU</h3><p>用方法 <code>to()</code> 可以将 <code>Tensor</code> 在CPU和GPU（需要硬件支持）之间相互移动。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 以下代码只有在PyTorch GPU版本上才会执行</span></span><br><span class="line"><span class="keyword">if</span> torch.cuda.is_available():</span><br><span class="line">    device = torch.device(<span class="string">"cuda"</span>)          <span class="comment"># GPU</span></span><br><span class="line">    y = torch.ones_like(x, device=device)  <span class="comment"># 直接创建一个在GPU上的Tensor</span></span><br><span class="line">    x = x.to(device)                       <span class="comment"># 等价于 .to("cuda")</span></span><br><span class="line">    z = x + y</span><br><span class="line">    print(z)</span><br><span class="line">    print(z.to(<span class="string">"cpu"</span>, torch.double))       <span class="comment"># to()还可以同时更改数据类型</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;🐳🐳&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;第一部分是PyTorch中有关Tensor的一些基本用法，因为之前并没有系统学习过PyTorch，所以现在看书的同时慢慢学习PyTorch的知识&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;第二部分是原书的知识和一些自己的理解&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;@&lt;a href&gt;TOC&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;张量 Tensor&lt;/strong&gt; &lt;/p&gt;&lt;p&gt;张量包含了一个数据集合，这个数据集合就是原始值变形而来的，它可以是一个任何维度的数据。tensor的rank就是其维度。&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://1979F.github.io/2021/02/17/%E7%89%9B%E5%AE%A221781%20%20%E7%89%9B%E5%85%84%E7%89%9B%E5%BC%9F/"/>
    <id>http://1979F.github.io/2021/02/17/牛客21781  牛兄牛弟/</id>
    <published>2021-02-17T04:22:06.246Z</published>
    <updated>2021-02-17T04:22:08.073Z</updated>
    
    <content type="html"><![CDATA[<p>链接：<a href="https://ac.nowcoder.com/acm/problem/21781" target="_blank" rel="noopener">https://ac.nowcoder.com/acm/problem/21781</a><br>来源：牛客网</p><p>时间限制：C/C++ 1秒，其他语言2秒<br>空间限制：C/C++ 32768K，其他语言65536K<br>64bit IO Format: %lld</p><p><strong>题目描述</strong> </p><p>一群牛兄牛弟准备去一家餐厅吃饭，已知他们是按照某个顺序先后到达餐厅的，第i个到达餐厅的要求坐在离门口至少a[i]的距离</p><a id="more"></a><p>牛兄牛弟们不准备让别人知道他们是兄弟，虽然他们长得比较像，他们决定任意两个兄弟之间的距离都要大于等于d</p><p>餐厅服务员记录下他们的需求之后，开始陆续给到来的牛兄弟们排座位，服务员每次会指定一个满足要求的离门口最近的座位给新到的牛</p><p><strong>输入描述:</strong></p><p>第一行输入两个整数n,d<br>第二行输入n个数a[i]</p><p>1 ≤ n ≤ 1000, 1 ≤ d,a[i] ≤ 106</p><p><strong>输出描述:</strong></p><p>输出n个数分别表示每一个牛的位置</p><p><img src="https://img-blog.csdnimg.cn/2021012412044651.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RzdW5kZXJlX3g=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">n, d = list(map(int, input().split()))</span><br><span class="line">a = list(map(int, input().split()))</span><br><span class="line"></span><br><span class="line">ans = []</span><br><span class="line">ans.append(a[<span class="number">0</span>])</span><br><span class="line">res = []</span><br><span class="line">res.append(a[<span class="number">0</span>])</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">    ans.append(a[i])</span><br><span class="line">    ans.sort()</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(len(ans)<span class="number">-1</span>):</span><br><span class="line">        <span class="keyword">if</span> ans[j+<span class="number">1</span>]-ans[j]&lt;d:</span><br><span class="line">            res.append(max(res)+d)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        res.append(a[i])</span><br><span class="line">        </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> res:</span><br><span class="line">    print(i, end=<span class="string">" "</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;链接：&lt;a href=&quot;https://ac.nowcoder.com/acm/problem/21781&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://ac.nowcoder.com/acm/problem/21781&lt;/a&gt;&lt;br&gt;来源：牛客网&lt;/p&gt;&lt;p&gt;时间限制：C/C++ 1秒，其他语言2秒&lt;br&gt;空间限制：C/C++ 32768K，其他语言65536K&lt;br&gt;64bit IO Format: %lld&lt;/p&gt;&lt;p&gt;&lt;strong&gt;题目描述&lt;/strong&gt; &lt;/p&gt;&lt;p&gt;一群牛兄牛弟准备去一家餐厅吃饭，已知他们是按照某个顺序先后到达餐厅的，第i个到达餐厅的要求坐在离门口至少a[i]的距离&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>快速幂模板（Python）</title>
    <link href="http://1979F.github.io/2021/02/17/%E5%BF%AB%E9%80%9F%E5%B9%82%E6%A8%A1%E6%9D%BF%EF%BC%88Python%EF%BC%89/"/>
    <id>http://1979F.github.io/2021/02/17/快速幂模板（Python）/</id>
    <published>2021-02-17T03:48:19.000Z</published>
    <updated>2021-02-17T05:33:26.573Z</updated>
    
    <content type="html"><![CDATA[<p>首先我们需要知道下面这个公式：<br><code>(a^b) mod c=((a mod c)^b) mod c</code></p><p>现在试着用最常规的方法计算 a^b</p><p><strong>算法一：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">spow</span><span class="params">(n, m)</span>:</span></span><br><span class="line">    res = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range (m):</span><br><span class="line">        res *= n</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">print(spow(<span class="number">2</span>, <span class="number">100</span>))</span><br></pre></td></tr></table></figure><a id="more"></a><p>显然这个算法的时间复杂度为 <code>O(n)</code>，我们需要找到一个复杂度较低的算法。<br>对于幂次运算，例如a^5</p><p>如果直接运算，需要5次循环了。</p><p>但是如果写成 a^5 = a*((a^2)^2)，如果是这样，就仅仅需要3次运算了，一下子省了两次运算，对于这次次数低的运算都如此可观，对于次数多的运算可想而知了。</p><p>对于上面的情况，计算幂的时候，明显需要分情况考虑。</p><p>1、当b为偶数的时候，a^b = (a^2)^(b/2)；<br>2、当b为奇数的时候，a^b = a*(a^2)((b-1)/2)。</p><p>时间复杂度降到了 <code>O(logn)</code></p><p><strong>算法二：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">qpow</span><span class="params">(n, m)</span>:</span></span><br><span class="line">    res = <span class="number">1</span></span><br><span class="line">    base = n</span><br><span class="line">    <span class="keyword">while</span> m != <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">if</span> (m&amp;<span class="number">1</span>) != <span class="number">0</span>:</span><br><span class="line">            res = res*base</span><br><span class="line">        base = base*base</span><br><span class="line">        m = m &gt;&gt; <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">print(qpow(<span class="number">2</span>, <span class="number">100</span>))</span><br></pre></td></tr></table></figure><p>如果要取余</p><p><strong>算法三：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mod = <span class="number">1000000007</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">qpow</span><span class="params">(n, m)</span>:</span></span><br><span class="line">    res = <span class="number">1</span></span><br><span class="line">    base = n</span><br><span class="line">    <span class="keyword">while</span> m != <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">if</span> (m&amp;<span class="number">1</span>) != <span class="number">0</span>:</span><br><span class="line">            res = res*base%mod</span><br><span class="line">        base = base*base%mod</span><br><span class="line">        m = m &gt;&gt; <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">print(qpow(<span class="number">2</span>, <span class="number">100</span>))</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;首先我们需要知道下面这个公式：&lt;br&gt;&lt;code&gt;(a^b) mod c=((a mod c)^b) mod c&lt;/code&gt;&lt;/p&gt;&lt;p&gt;现在试着用最常规的方法计算 a^b&lt;/p&gt;&lt;p&gt;&lt;strong&gt;算法一：&lt;/strong&gt;&lt;/p&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;spow&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(n, m)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    res = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; i &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; range (m):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        res *= n&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; res&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;print(spow(&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;100&lt;/span&gt;))&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="算法" scheme="http://1979F.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>牛客16732 序列（排列组合）</title>
    <link href="http://1979F.github.io/2021/02/17/%E7%89%9B%E5%AE%A216732%20%E5%BA%8F%E5%88%97%EF%BC%88%E6%8E%92%E5%88%97%E7%BB%84%E5%90%88%EF%BC%89/"/>
    <id>http://1979F.github.io/2021/02/17/牛客16732 序列（排列组合）/</id>
    <published>2021-02-17T03:48:19.000Z</published>
    <updated>2021-02-17T05:31:15.015Z</updated>
    
    <content type="html"><![CDATA[<p>链接：<a href="https://ac.nowcoder.com/acm/problem/16732" target="_blank" rel="noopener">https://ac.nowcoder.com/acm/problem/16732</a><br>来源：牛客网</p><p>时间限制：C/C++ 1秒，其他语言2秒<br>空间限制：C/C++ 262144K，其他语言524288K<br>64bit IO Format: %lld</p><p><strong>题目描述</strong> </p><p>有一个长度为n的序列a，已知a[1]=a[n]=1，且对于2 &lt;= x &lt;= n，a[x] / a[x-1]是以下三个数字之一 [ 1，-2，0.5 ],问有多少种不同的序列满足题意。<br>两个序列不同当且仅当它们有至少一个位置上的数字不同，序列a可以为任何实数。</p><a id="more"></a><p><strong>输入描述:</strong></p><p>一个整数 表示n (1&lt;= n &lt;= 1e3)</p><p><strong>输出描述:</strong></p><p>一个整数 表示答案模 10^9^ +7</p><p><img src="https://img-blog.csdnimg.cn/20210217113849153.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RzdW5kZXJlX3g=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>直接整体来看，a[x] = a[x-1]*[1, -2, 0.5]，那么等于选出n-1个数值相乘</p><p>最后答案要是1，所以-2就必须有偶数个，同理0.5的个数要等于-2，顺序无关</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">n = int(input())</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line">MOD = <span class="number">1000000007</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">c</span><span class="params">(m, n)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> math.factorial(m) // math.factorial(n) // math.factorial(m - n) % MOD</span><br><span class="line">ans = <span class="number">0</span></span><br><span class="line">i = <span class="number">0</span></span><br><span class="line">num = n<span class="number">-1</span></span><br><span class="line"><span class="keyword">while</span> i &lt;= num // <span class="number">2</span>:</span><br><span class="line">    ans = (ans + c(num, i) * c(num - i, i)) % MOD</span><br><span class="line">    i += <span class="number">2</span></span><br><span class="line">print(ans)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;链接：&lt;a href=&quot;https://ac.nowcoder.com/acm/problem/16732&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://ac.nowcoder.com/acm/problem/16732&lt;/a&gt;&lt;br&gt;来源：牛客网&lt;/p&gt;&lt;p&gt;时间限制：C/C++ 1秒，其他语言2秒&lt;br&gt;空间限制：C/C++ 262144K，其他语言524288K&lt;br&gt;64bit IO Format: %lld&lt;/p&gt;&lt;p&gt;&lt;strong&gt;题目描述&lt;/strong&gt; &lt;/p&gt;&lt;p&gt;有一个长度为n的序列a，已知a[1]=a[n]=1，且对于2 &amp;lt;= x &amp;lt;= n，a[x] / a[x-1]是以下三个数字之一 [ 1，-2，0.5 ],问有多少种不同的序列满足题意。&lt;br&gt;两个序列不同当且仅当它们有至少一个位置上的数字不同，序列a可以为任何实数。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="NOWCODER" scheme="http://1979F.github.io/tags/NOWCODER/"/>
    
  </entry>
  
  <entry>
    <title>牛客16596 计算系数（排列组合）</title>
    <link href="http://1979F.github.io/2021/02/17/%E8%AE%A1%E7%AE%97%E7%B3%BB%E6%95%B0/"/>
    <id>http://1979F.github.io/2021/02/17/计算系数/</id>
    <published>2021-02-17T01:11:40.000Z</published>
    <updated>2021-02-17T05:30:23.202Z</updated>
    
    <content type="html"><![CDATA[<p>链接：<a href="https://ac.nowcoder.com/acm/problem/16596" target="_blank" rel="noopener">https://ac.nowcoder.com/acm/problem/16596</a><br>来源：牛客网</p><p>时间限制：C/C++ 1秒，其他语言2秒<br>空间限制：C/C++ 131072K，其他语言262144K<br>64bit IO Format: %lld</p><p><strong>题目描述</strong> </p><p>给定一个多项式(ax+by)k，请求出多项式展开后x^n * y^m项的系数。</p><a id="more"></a><p><strong>输入描述:</strong></p><p>共一行，包含5个整数，分别为a，b，k，n，m，每两个整数之间用一个空格隔开。</p><p><strong>输出描述:</strong></p><p>输出共1行，包含一个整数，表示所求的系数，这个系数可能很大，输出对10007取模后的结果。</p><p><img src="https://img-blog.csdnimg.cn/2021021709105043.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RzdW5kZXJlX3g=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">a, b, k, n, m = list(map(int, input().split()))</span><br><span class="line"></span><br><span class="line">k1=<span class="number">1</span></span><br><span class="line">m1=<span class="number">1</span></span><br><span class="line">n1=<span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,k+<span class="number">1</span>):</span><br><span class="line">    k1 = k1*i</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,m+<span class="number">1</span>):</span><br><span class="line">    m1 = m1*i</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,n+<span class="number">1</span>):</span><br><span class="line">    n1 = n1*i</span><br><span class="line">s = ((k1//(m1*n1))*a**n*b**m)%<span class="number">10007</span></span><br><span class="line">print(s)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;链接：&lt;a href=&quot;https://ac.nowcoder.com/acm/problem/16596&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://ac.nowcoder.com/acm/problem/16596&lt;/a&gt;&lt;br&gt;来源：牛客网&lt;/p&gt;&lt;p&gt;时间限制：C/C++ 1秒，其他语言2秒&lt;br&gt;空间限制：C/C++ 131072K，其他语言262144K&lt;br&gt;64bit IO Format: %lld&lt;/p&gt;&lt;p&gt;&lt;strong&gt;题目描述&lt;/strong&gt; &lt;/p&gt;&lt;p&gt;给定一个多项式(ax+by)k，请求出多项式展开后x^n * y^m项的系数。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="NOWCODER" scheme="http://1979F.github.io/tags/NOWCODER/"/>
    
  </entry>
  
  <entry>
    <title>智力题：64匹马8个跑道，至少需要多少轮才能挑选出最快的4匹马</title>
    <link href="http://1979F.github.io/2021/02/17/%E6%99%BA%E5%8A%9B%E9%A2%98%EF%BC%9A64%E5%8C%B9%E9%A9%AC8%E4%B8%AA%E8%B7%91%E9%81%93%EF%BC%8C%E8%87%B3%E5%B0%91%E9%9C%80%E8%A6%81%E5%A4%9A%E5%B0%91%E8%BD%AE%E6%89%8D%E8%83%BD%E6%8C%91%E9%80%89%E5%87%BA%E6%9C%80%E5%BF%AB%E7%9A%844%E5%8C%B9%E9%A9%AC/"/>
    <id>http://1979F.github.io/2021/02/17/智力题：64匹马8个跑道，至少需要多少轮才能挑选出最快的4匹马/</id>
    <published>2021-02-17T00:58:45.000Z</published>
    <updated>2021-02-17T05:29:22.929Z</updated>
    
    <content type="html"><![CDATA[<div id="article_content" class="article_content clearfix">        <link rel="stylesheet" href="https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/ck_htmledit_views-b5506197d8.css">                <div id="content_views" class="markdown_views prism-atom-one-dark"><h4><a id="_0"></a>题意：</h4> <p>64匹马8个跑道需要多少轮才能挑选出最快的四匹马？</p> <h4><a id="_3"></a>解法：</h4> <p>1.分成八组，每组8匹马。</p> <p>2.八组内部分别比赛，总共比八场，对每组的马排序。<br> 每组的后四匹显然不是答案，直接淘汰。</p> <p>现在只剩下八组，每组4匹。</p> <p>3.选出八组的第一名进行比赛，后四名所在的组的所有马显然不是答案，直接淘汰。</p> <p>现在只剩下前四组，每组只剩下前四匹马，总共十六匹。</p> <p>4.剩下四组中，第四组的后三匹一定不是答案，因为比他们快的已经至少有四匹了（四个组的第一匹），<br> 同时，第三组的后两匹一定不是答案；第二组的后一匹一定不是答案。理由同上。</p> <p>其实第一组的第一匹一定是答案，因为最快。</p> <p>那么现在只剩下第一组3匹，第二组3匹，第三组2匹，第四组1匹。总共9匹。</p> <p>5.剩下的9匹用两次选出前3匹即可。</p> <p>总比赛次数为：8+1+2=11次。</p> <hr>                </div><div><div></div></div>                <link href="https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/markdown_views-d7a94ec6ab.css" rel="stylesheet">                <link href="https://csdnimg.cn/release/blogv2/dist/mdeditor/css/style-80ad9b4f5b.css" rel="stylesheet">        </div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;div id=&quot;article_content&quot; class=&quot;article_content clearfix&quot;&gt;
        &lt;link rel=&quot;stylesheet&quot; href=&quot;https://csdnimg.cn/release/blogv2/dist/mded
      
    
    </summary>
    
    
    
      <category term="算法" scheme="http://1979F.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>牛客16429 组合数问题（二维前缀和、杨辉三角）</title>
    <link href="http://1979F.github.io/2021/02/16/%E7%89%9B%E5%AE%A216429%20%20%E7%BB%84%E5%90%88%E6%95%B0%E9%97%AE%E9%A2%98%EF%BC%88%E4%BA%8C%E7%BB%B4%E5%89%8D%E7%BC%80%E5%92%8C%E3%80%81%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92%EF%BC%89/"/>
    <id>http://1979F.github.io/2021/02/16/牛客16429  组合数问题（二维前缀和、杨辉三角）/</id>
    <published>2021-02-16T09:18:25.000Z</published>
    <updated>2021-02-17T05:28:08.613Z</updated>
    
    <content type="html"><![CDATA[<p>链接：<a href="https://ac.nowcoder.com/acm/problem/16429" target="_blank" rel="noopener">https://ac.nowcoder.com/acm/problem/16429</a><br>来源：牛客网</p><p>时间限制：C/C++ 1秒，其他语言2秒<br>空间限制：C/C++ 262144K，其他语言524288K<br>64bit IO Format: %lld</p><p><strong>题目描述</strong><br>组合数表示的是从 n 个物品中选出 m 个物品的方案数。举个例子，从 (1, 2, 3) 三个物品中选择两个物品可以有 (1, 2)，(1, 3)，(2, 3) 这三种选择方法。<br>根据组合数的定义，我们可以给出计算组合数的一般公式：<br><img src="https://img-blog.csdnimg.cn/20210216171443582.png" alt="在这里插入图片描述"><br>其中 n! = 1×2×⋯×n。</p><a id="more"></a><p><img src="https://img-blog.csdnimg.cn/20210216171608748.png" alt="在这里插入图片描述"></p><p><strong>输入描述:</strong></p><p>第一行有两个整数 t，k，其中 t 代表该测试点总共有多少组测试数据，k 的意义见 「题目描述」。<br>接下来 t 行每行两个整数 n，m，其中 n，m 的意义见「题目描述」。</p><p><strong>输出描述:</strong><br><img src="https://img-blog.csdnimg.cn/20210216171638467.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210216171710773.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RzdW5kZXJlX3g=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">t, k = list(map(int, input().split()))</span><br><span class="line">a = [[<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2002</span>)] <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">2002</span>)]</span><br><span class="line">ans = [[<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2002</span>)] <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">2002</span>)]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range (<span class="number">2001</span>):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range (<span class="number">1</span>+i):</span><br><span class="line">        <span class="keyword">if</span> j==<span class="number">0</span>:</span><br><span class="line">            a[i][j] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            a[i][j] = (a[i<span class="number">-1</span>][j] + a[i<span class="number">-1</span>][j<span class="number">-1</span>])%k</span><br><span class="line">        <span class="keyword">if</span> a[i][j] == <span class="number">0</span>:</span><br><span class="line">            ans[i][j] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">for i in range (2001):</span></span><br><span class="line"><span class="string">    for j in range (i+1):</span></span><br><span class="line"><span class="string">        if i==0 and j==0:</span></span><br><span class="line"><span class="string">            continue</span></span><br><span class="line"><span class="string">        elif i==j:</span></span><br><span class="line"><span class="string">            ans[i][j] = ans[i][j-1]</span></span><br><span class="line"><span class="string">        elif j==0:</span></span><br><span class="line"><span class="string">            ans[i][j] = ans[i-1][j]</span></span><br><span class="line"><span class="string">        else:</span></span><br><span class="line"><span class="string">            ans[i][j] = ans[i-1][j] + ans[i][j-1] - ans[i-1][j-1] + ans[i][j]</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range (<span class="number">2001</span>):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range (<span class="number">2001</span>):</span><br><span class="line">        <span class="keyword">if</span> i != <span class="number">0</span>:</span><br><span class="line">            ans[i][j]+=ans[i<span class="number">-1</span>][j]</span><br><span class="line">        <span class="keyword">if</span> j != <span class="number">0</span>:</span><br><span class="line">            ans[i][j]+=ans[i][j<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">if</span> i != <span class="number">0</span> <span class="keyword">and</span> j != <span class="number">0</span>:</span><br><span class="line">            ans[i][j]-=ans[i<span class="number">-1</span>][j<span class="number">-1</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range (t):</span><br><span class="line">    n, m = list(map(int, input().split()))</span><br><span class="line">    m = min(n, m)</span><br><span class="line">    print(ans[n][m])</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;链接：&lt;a href=&quot;https://ac.nowcoder.com/acm/problem/16429&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://ac.nowcoder.com/acm/problem/16429&lt;/a&gt;&lt;br&gt;来源：牛客网&lt;/p&gt;&lt;p&gt;时间限制：C/C++ 1秒，其他语言2秒&lt;br&gt;空间限制：C/C++ 262144K，其他语言524288K&lt;br&gt;64bit IO Format: %lld&lt;/p&gt;&lt;p&gt;&lt;strong&gt;题目描述&lt;/strong&gt;&lt;br&gt;组合数表示的是从 n 个物品中选出 m 个物品的方案数。举个例子，从 (1, 2, 3) 三个物品中选择两个物品可以有 (1, 2)，(1, 3)，(2, 3) 这三种选择方法。&lt;br&gt;根据组合数的定义，我们可以给出计算组合数的一般公式：&lt;br&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20210216171443582.png&quot; alt=&quot;在这里插入图片描述&quot;&gt;&lt;br&gt;其中 n! = 1×2×⋯×n。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="NOWCODER" scheme="http://1979F.github.io/tags/NOWCODER/"/>
    
  </entry>
  
  <entry>
    <title>二位前缀和详解</title>
    <link href="http://1979F.github.io/2021/02/16/%E4%BA%8C%E7%BB%B4%E5%89%8D%E7%BC%80%E5%92%8C%E8%AF%A6%E8%A7%A3/"/>
    <id>http://1979F.github.io/2021/02/16/二维前缀和详解/</id>
    <published>2021-02-16T03:53:11.000Z</published>
    <updated>2021-02-17T05:27:20.623Z</updated>
    
    <content type="html"><![CDATA[<p>什么是<strong>二维前缀和</strong> ?</p><p>比如我们有这样一个矩阵a，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1 2 4 3</span><br><span class="line">5 1 2 4</span><br><span class="line">6 3 5 9</span><br></pre></td></tr></table></figure><p>我们定义一个矩阵sum，其中<br><img src="https://img-blog.csdnimg.cn/20210216160734629.png" alt="sum_{x,y} = \sum\limits_{i=1}^x \sum\limits_{j=1}^y a_{i,j}"><br>那么这个矩阵就是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1  3  7  10</span><br><span class="line">6  9  15 22</span><br><span class="line">12 18 29 45</span><br></pre></td></tr></table></figure><p>建立在<strong>一维前缀和</strong>之上，我们要求一个矩阵内一个任意的子矩阵的数的和，我们就可以用二维前缀和，我们还是用DP来预处理，状态和一维前缀和差不多，只不过我们多加了一维，<code>DP[i][j]</code> 表示<code>（1,1）</code>这个点与<code>（i，j）</code>这个点两个点分别为左上角和右下角所组成的矩阵内的数的和，好好想一下状态转移方程：</p><a id="more"></a><p><code>DP[i][j]=DP[i-1][j]+DP[i][j-1]-DP[i-1][j-1]+map[i][j]</code></p><p>怎么来的呢？我们画一下图就知道了。<br><img src="https://img-blog.csdnimg.cn/20210216114834180.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RzdW5kZXJlX3g=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>这张图就知道了 <code>（i，j）</code> 可以由 <code>（i-1，j）</code> 和 <code>（i,j-1）</code> 两块构成，不过要注意两个点</p><p>1、有一块矩阵我们<strong>重复加了</strong>，也就是 <code>（i-1，j-1）</code> 这一块，所以我们要<strong>减去它</strong>。</p><p>2、我们这个矩阵是<strong>不完整</strong>的，由图可知我们<strong>还有一块深蓝色的没有加</strong>，也就是 <code>（i，j）</code> 这一点，所以我们要再加上 <code>map[i][j]</code> 也就是题目给出的矩阵中这一格的数。</p><p>这样我们就预处理完了，现在讲一下怎么通过我们的预处理从而快速地得出我们想要的任意子矩阵中的和，我们定义 <code>（x1，y1）</code> 为我们想要子矩阵的左上角， <code>（x2，y2）</code> 为我们想要子矩阵的右下角，然后我们画图想一想。</p><p><img src="https://img-blog.csdnimg.cn/20210216115036829.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RzdW5kZXJlX3g=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>我们可以通过 <code>DP[x2][y2]</code> 来计算，我们通过图可以发现这个距离我们要的还差红色的部分看看怎么表示红色部分？我们可以分割成两块，分别是 <code>DP[x1][y2]</code> 和 <code>DP[x2][y1]</code> 我们发现有一块重复减了，所以我们再加上它即 <code>DP[x1][y1]</code>。</p><p><strong>有一点注意</strong>，因为画图和定义原因我们发现边界好像不对，我们来看看，我们定义的状态是整个矩阵包括边的和，而我们要求的也是要包括边的，所以我们要再改一下，把 <code>DP[x1][y2]</code> 和 <code>DP[x2][y1]</code>和 <code>DP[x1][y1]</code> 分别改成 <code>DP[x1-1][y2]</code> 和 <code>DP[x2][y1-1]</code> 和 <code>DP[x1-1][y1-1]</code></p><p>这样一减我们就可以得到自己想要的答案，整理可得公式，<code>DP[x2][y2]-DP[x1-1][y2]-DP[x2][y1-1]+DP[x1-1][y1-1]</code> 这样我们就可以做到 <code>O（1）</code> 之内查询，很奇妙吧，我们看一下实现代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">2000</span>][<span class="number">2000</span>],<span class="built_in">map</span>[<span class="number">2000</span>][<span class="number">2000</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> m,n,k;<span class="comment">//所给的矩阵是n*m的,有k组查询 </span></span><br><span class="line"><span class="built_in">cin</span> &gt;&gt;n&gt;&gt;m&gt;&gt;k;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt;<span class="built_in">map</span>[i][j];</span><br><span class="line"><span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="keyword">sizeof</span>(dp));</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="comment">//预处理一波 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">dp[i][j]=dp[i<span class="number">-1</span>][j]+dp[i][j<span class="number">-1</span>]-dp[i<span class="number">-1</span>][j<span class="number">-1</span>]+<span class="built_in">map</span>[i][j];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=k;i++)<span class="comment">//接受查询 </span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> x1,x2,y1,y2;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt;x1&gt;&gt;y1&gt;&gt;x2&gt;&gt;y2;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt;(dp[x2][y2]+dp[x1<span class="number">-1</span>][y1<span class="number">-1</span>]-dp[x1<span class="number">-1</span>][y2]-dp[x2][y1<span class="number">-1</span>])&lt;&lt;<span class="built_in">endl</span>;<span class="comment">//O（1）查询 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考博文:<a href="https://blog.csdn.net/qq_34990731/article/details/82807870" target="_blank" rel="noopener">https://blog.csdn.net/qq_34990731/article/details/82807870</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;什么是&lt;strong&gt;二维前缀和&lt;/strong&gt; ?&lt;/p&gt;&lt;p&gt;比如我们有这样一个矩阵a，如下所示：&lt;/p&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1 2 4 3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5 1 2 4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6 3 5 9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;我们定义一个矩阵sum，其中&lt;br&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20210216160734629.png&quot; alt=&quot;sum_{x,y} = \sum\limits_{i=1}^x \sum\limits_{j=1}^y a_{i,j}&quot;&gt;&lt;br&gt;那么这个矩阵就是这样的：&lt;/p&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1  3  7  10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6  9  15 22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12 18 29 45&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;建立在&lt;strong&gt;一维前缀和&lt;/strong&gt;之上，我们要求一个矩阵内一个任意的子矩阵的数的和，我们就可以用二维前缀和，我们还是用DP来预处理，状态和一维前缀和差不多，只不过我们多加了一维，&lt;code&gt;DP[i][j]&lt;/code&gt; 表示&lt;code&gt;（1,1）&lt;/code&gt;这个点与&lt;code&gt;（i，j）&lt;/code&gt;这个点两个点分别为左上角和右下角所组成的矩阵内的数的和，好好想一下状态转移方程：&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="算法" scheme="http://1979F.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>牛客15666 又见斐波那契数列（矩阵快速幂）</title>
    <link href="http://1979F.github.io/2021/02/03/%E7%89%9B%E5%AE%A215666%20%E5%8F%88%E8%A7%81%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%EF%BC%88%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82%EF%BC%89/"/>
    <id>http://1979F.github.io/2021/02/03/牛客15666 又见斐波那契（矩阵快速幂）/</id>
    <published>2021-02-03T14:28:06.000Z</published>
    <updated>2021-02-17T05:26:29.121Z</updated>
    
    <content type="html"><![CDATA[<p>链接：<a href="https://ac.nowcoder.com/acm/problem/15666" target="_blank" rel="noopener">https://ac.nowcoder.com/acm/problem/15666</a><br>来源：牛客网</p><p>时间限制：C/C++ 1秒，其他语言2秒<br>空间限制：C/C++ 32768K，其他语言65536K<br>64bit IO Format: %lld</p><p><strong>题目描述</strong><br><img src="https://img-blog.csdnimg.cn/20210203222510854.png" alt="在这里插入图片描述"></p><p><strong>输入描述:</strong></p><p>第一行是一个整数T(1 ≤ T ≤ 1000)，表示样例的个数。<br>以后每个样例一行，是一个整数n(1 ≤ n ≤ 1018)。</p><a id="more"></a><p><strong>输出描述:</strong></p><p>每个样例输出一行，一个整数，表示F(n) mod 1000000007。<br><img src="https://img-blog.csdnimg.cn/20210203222546603.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RzdW5kZXJlX3g=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>列出等式，<br><img src="https://img-blog.csdnimg.cn/20210203222626605.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RzdW5kZXJlX3g=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>可以求出矩阵A为：<br>[<br>    [1,1,1,1,1,1],<br>    [1,0,0,0,0,0],<br>    [0,0,1,3,3,1],<br>    [0,0,0,1,2,1],<br>    [0,0,0,0,1,1],<br>    [0,0,0,0,0,1],<br>]</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">GLOBAL_MOD = <span class="number">1000000007</span></span><br><span class="line">T = int(input())</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(self, n: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span> <span class="keyword">or</span> n == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> n</span><br><span class="line">        res = self.matrixpower(n<span class="number">-1</span>)</span><br><span class="line">        res = res[<span class="number">0</span>][<span class="number">0</span>]*<span class="number">1</span>+res[<span class="number">0</span>][<span class="number">1</span>]*<span class="number">0</span>+res[<span class="number">0</span>][<span class="number">2</span>]*<span class="number">8</span>+res[<span class="number">0</span>][<span class="number">3</span>]*<span class="number">4</span>+res[<span class="number">0</span>][<span class="number">4</span>]*<span class="number">2</span>+res[<span class="number">0</span>][<span class="number">5</span>]</span><br><span class="line">        res = res % GLOBAL_MOD</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">matrixpower</span><span class="params">(self, power)</span>:</span></span><br><span class="line">        <span class="comment"># res初始值为单位矩阵</span></span><br><span class="line">        res = [[<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],[<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],[<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],[<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>],[<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>],[<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>]] </span><br><span class="line">        base = [[<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>],[<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],[<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">1</span>],[<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>],[<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>],[<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>]] <span class="comment"># 这个是我们根据斐波那契数列的特点构造的矩阵 </span></span><br><span class="line">        <span class="keyword">while</span> power !=<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> power&amp;<span class="number">1</span> !=<span class="number">0</span>:</span><br><span class="line">                res = self.multimatrix(res, base)</span><br><span class="line">            power = power&gt;&gt;<span class="number">1</span></span><br><span class="line">            base = self.multimatrix(base, base)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">multimatrix</span><span class="params">(self, m1, m2)</span>:</span></span><br><span class="line">        n = len(m1)</span><br><span class="line">        res = [[<span class="number">0</span>]*n <span class="keyword">for</span> i <span class="keyword">in</span> range(n)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">                <span class="keyword">for</span> k <span class="keyword">in</span> range(n):</span><br><span class="line">                    res[i][j] = (res[i][j]+m1[i][k] * m2[k][j])%GLOBAL_MOD</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(T):</span><br><span class="line">    n = int(input())</span><br><span class="line">    ans = Solution()</span><br><span class="line">    print(ans.f(n))</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;链接：&lt;a href=&quot;https://ac.nowcoder.com/acm/problem/15666&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://ac.nowcoder.com/acm/problem/15666&lt;/a&gt;&lt;br&gt;来源：牛客网&lt;/p&gt;&lt;p&gt;时间限制：C/C++ 1秒，其他语言2秒&lt;br&gt;空间限制：C/C++ 32768K，其他语言65536K&lt;br&gt;64bit IO Format: %lld&lt;/p&gt;&lt;p&gt;&lt;strong&gt;题目描述&lt;/strong&gt;&lt;br&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20210203222510854.png&quot; alt=&quot;在这里插入图片描述&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;输入描述:&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;第一行是一个整数T(1 ≤ T ≤ 1000)，表示样例的个数。&lt;br&gt;以后每个样例一行，是一个整数n(1 ≤ n ≤ 1018)。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="NOWCODER" scheme="http://1979F.github.io/tags/NOWCODER/"/>
    
  </entry>
  
  <entry>
    <title>牛客14607 递推（矩阵快速幂构造)</title>
    <link href="http://1979F.github.io/2021/02/02/%E7%89%9B%E5%AE%A214607%20%E9%80%92%E6%8E%A8%EF%BC%88%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82%E6%9E%84%E9%80%A0%EF%BC%89/"/>
    <id>http://1979F.github.io/2021/02/02/牛客14607 递推（矩阵快速幂构造）/</id>
    <published>2021-02-02T06:54:13.000Z</published>
    <updated>2021-02-17T05:25:45.651Z</updated>
    
    <content type="html"><![CDATA[<p>链接：<a href="https://ac.nowcoder.com/acm/problem/14607" target="_blank" rel="noopener">https://ac.nowcoder.com/acm/problem/14607</a><br>来源：牛客网</p><p>时间限制：C/C++ 2秒，其他语言4秒<br>空间限制：C/C++ 131072K，其他语言262144K<br>64bit IO Format: %lld</p><p><strong>题目描述</strong> </p><p>JYM和XJ转眼就从小学上了高中。在学习递推的时候，JYM在纸上随手写了一个递推关系式：an=2<em>an-1，a0=0。写完这个递推式，JYM拿给XJ看，XJ觉得太过简单，于是大笔一挥，在等式右边又加了一个式子，变成了这样：an=2</em>an-1+n2。JYM看到这个式子，想要算几个项来看看，可是一算就发现这个数据量太大了，你能帮他解决这个问题吗？</p><a id="more"></a><p><strong>输入描述:</strong></p><p>输入数据有多组（不超过100组数据），每组数据包含一个整数N&lt;=10^18</p><p><strong>输出描述:</strong></p><p>一个整数X，表示递推式第n项的值。由于数字太大，因此结果对于1000000009取模后输出。</p><p><img src="https://img-blog.csdnimg.cn/20210202145307298.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RzdW5kZXJlX3g=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>构造出来的基矩阵base:<br><img src="https://img-blog.csdnimg.cn/20210202145406144.png" alt="在这里插入图片描述"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">GLOBAL_MOD = <span class="number">1000000009</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(self, n: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> n</span><br><span class="line">        res = self.matrixpower(n<span class="number">-1</span>)</span><br><span class="line">        res = res[<span class="number">0</span>][<span class="number">0</span>]+res[<span class="number">0</span>][<span class="number">1</span>]+res[<span class="number">0</span>][<span class="number">2</span>]+res[<span class="number">0</span>][<span class="number">3</span>]</span><br><span class="line">        res = res % GLOBAL_MOD</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">matrixpower</span><span class="params">(self, power)</span>:</span></span><br><span class="line">        <span class="comment"># res初始值为单位矩阵</span></span><br><span class="line">        res = [[<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],[<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>],[<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>],[<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>]] </span><br><span class="line">        base = [[<span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>],[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>],[<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>],[<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>]] <span class="comment"># 这个是我们构造的矩阵 </span></span><br><span class="line">        <span class="keyword">while</span> power !=<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> power&amp;<span class="number">1</span> !=<span class="number">0</span>:</span><br><span class="line">                res = self.multimatrix(res, base)</span><br><span class="line">            power = power&gt;&gt;<span class="number">1</span></span><br><span class="line">            base = self.multimatrix(base, base)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">multimatrix</span><span class="params">(self, m1, m2)</span>:</span></span><br><span class="line">        n = len(m1)</span><br><span class="line">        res = [[<span class="number">0</span>]*n <span class="keyword">for</span> i <span class="keyword">in</span> range(n)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">                <span class="keyword">for</span> k <span class="keyword">in</span> range(n):</span><br><span class="line">                    res[i][j] = (res[i][j]+m1[i][k] * m2[k][j])%GLOBAL_MOD</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        n = int(input())</span><br><span class="line">        ans = Solution()</span><br><span class="line">        print(ans.f(n))</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;链接：&lt;a href=&quot;https://ac.nowcoder.com/acm/problem/14607&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://ac.nowcoder.com/acm/problem/14607&lt;/a&gt;&lt;br&gt;来源：牛客网&lt;/p&gt;&lt;p&gt;时间限制：C/C++ 2秒，其他语言4秒&lt;br&gt;空间限制：C/C++ 131072K，其他语言262144K&lt;br&gt;64bit IO Format: %lld&lt;/p&gt;&lt;p&gt;&lt;strong&gt;题目描述&lt;/strong&gt; &lt;/p&gt;&lt;p&gt;JYM和XJ转眼就从小学上了高中。在学习递推的时候，JYM在纸上随手写了一个递推关系式：an=2&lt;em&gt;an-1，a0=0。写完这个递推式，JYM拿给XJ看，XJ觉得太过简单，于是大笔一挥，在等式右边又加了一个式子，变成了这样：an=2&lt;/em&gt;an-1+n2。JYM看到这个式子，想要算几个项来看看，可是一算就发现这个数据量太大了，你能帮他解决这个问题吗？&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="NOWCODER" scheme="http://1979F.github.io/tags/NOWCODER/"/>
    
  </entry>
  
  <entry>
    <title>牛客18987 粉樱花之恋（矩阵快速幂、斐波那契数列）</title>
    <link href="http://1979F.github.io/2021/02/02/%E7%89%9B%E5%AE%A218987%20%E7%B2%89%E5%98%A4%E8%8A%B1%E4%B9%8B%E6%81%8B%EF%BC%88%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82%E3%80%81%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97%EF%BC%89/"/>
    <id>http://1979F.github.io/2021/02/02/牛客18987 粉嘤花之恋（矩阵快速幂、斐波那契数列）/</id>
    <published>2021-02-02T03:44:46.000Z</published>
    <updated>2021-02-17T05:24:55.139Z</updated>
    
    <content type="html"><![CDATA[<p>链接：<a href="https://ac.nowcoder.com/acm/problem/18987" target="_blank" rel="noopener">https://ac.nowcoder.com/acm/problem/18987</a><br>来源：牛客网</p><p>时间限制：C/C++ 1秒，其他语言2秒<br>空间限制：C/C++ 32768K，其他语言65536K<br>64bit IO Format: %lld</p><p><strong>题目描述</strong> </p><p>qn是个特别可爱的小哥哥，qy是个特别好的小姐姐，他们两个是一对好朋友 [ cp (划掉~)<br>又是一年嘤花烂漫时，小qn于是就邀请了qy去嘤花盛开的地方去玩。当qy和qn来到了田野里时，qy惊奇的发现，嘤花花瓣以肉眼可见的速度从树上长了出来。<br>仔细看看的话，花瓣实际上是以一定规律长出来的，而且，每次张成新的花瓣的时候，上一次的花瓣就会都落到地上，而且不会消失。<br>花瓣生长的规律是，当次数大于等于2时，第i次长出来的花瓣个数和上一次张出来的花瓣个数的差是斐波那契数列的第i-1项。初始的时候地上没有花瓣，树上的花瓣个数为1，第一次生长的花瓣个数为1。初始的那个花瓣就落到了地上<br>现在，小qn想知道，经过k次生长之后，树上和地上的总花瓣个数是多少?<br>ps:斐波那契数列:<br>    f[1]=f[2]=1;f[i]=f[i-1]+f[i-2] (i&gt;=2且i ∈  N+) </p><a id="more"></a><p><strong>输入描述:</strong></p><p>一行一个数k</p><p><strong>输出描述:</strong></p><p>一行一个数m，表示第k次生长过后，树上和地上的总花瓣数是多少。由于答案会很大，请你将答案mod 998244353后输出<br><img src="https://img-blog.csdnimg.cn/2021020211434327.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RzdW5kZXJlX3g=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>题意不难理解，最终结果是要求斐波那契数列的前k+1项之和  ， 又因为Sn = f(n+2) - 1， 所以最后就是求 f(n+3)-1</p><p>普通的斐波那契数列求解可以用递归（时间复杂度O(2^N)），但是这里的数据太大，会超时，<br>所以这里用矩阵快速幂（时间复杂度O（logN））来求解。</p><p><img src="https://img-blog.csdnimg.cn/20210202114652496.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210202114626974.png" alt="在这里插入图片描述"><br><code>[F(n),F(n-1)] = [F(1), F(0)] * [[1 1] [1 0]]^(n-1)</code></p><p>F(n)的获取方法有两种</p><ul><li>第一种，是取矩阵运算结果的第一行第一列，<br>由[F(n),F(n-1)] = [F(1), F(0)] * [[1 1] [1 0]]^(n-1)得，矩阵运算n-1次</li><li>第二种，取矩阵运算结果第一行元素之和，<br>由[F(n-1),F(n-2)] = [F(1), F(0)] * [[1 1] [1 0]]^(n-2), F(n) = F(n-1)+F(n-2),矩阵运算n-2次</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">GLOBAL_MOD = <span class="number">998244353</span></span><br><span class="line">k = int(input())</span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">题意不难理解，最终结果是要求斐波那契数列的前k+1项之和  ， 又因为Sn = f(n+2) - 1， 所以最后就是求 f(n+3)-1</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">普通的斐波那契数列求解可以用递归（时间复杂度O(2^N)），但是这里的数据太大，会超时， </span></span><br><span class="line"><span class="string">所以这里用矩阵快速幂（时间复杂度O（logN））来求解。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">[F(n),F(n-1)] = [F(1), F(0)] * [[1 1] [1 0]]^(n-1)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">F(n)的获取方法有两种</span></span><br><span class="line"><span class="string">第一种，是取矩阵运算结果的第一行第一列，</span></span><br><span class="line"><span class="string">由[F(n),F(n-1)] = [F(1), F(0)] * [[1 1] [1 0]]^(n-1)得，矩阵运算n-1次</span></span><br><span class="line"><span class="string">第二种，取矩阵运算结果第一行元素之和，</span></span><br><span class="line"><span class="string">由[F(n-1),F(n-2)] = [F(1), F(0)] * [[1 1] [1 0]]^(n-2), F(n) = F(n-1)+F(n-2),矩阵运算n-2次</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fib</span><span class="params">(self, n: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> n</span><br><span class="line">        res = self.matrixpower(n<span class="number">-1</span>)</span><br><span class="line">        res = res[<span class="number">0</span>][<span class="number">0</span>]<span class="number">-1</span></span><br><span class="line">        res = res % GLOBAL_MOD</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">matrixpower</span><span class="params">(self, power)</span>:</span></span><br><span class="line">        <span class="comment"># res初始值为单位矩阵</span></span><br><span class="line">        res = [[<span class="number">1</span>, <span class="number">0</span>],[<span class="number">0</span>, <span class="number">1</span>]] </span><br><span class="line">        base = [[<span class="number">1</span>, <span class="number">1</span>],[<span class="number">1</span>, <span class="number">0</span>]] <span class="comment"># 这个是我们根据斐波那契数列的特点构造的矩阵 </span></span><br><span class="line">        <span class="keyword">while</span> power !=<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> power&amp;<span class="number">1</span> !=<span class="number">0</span>:</span><br><span class="line">                res = self.multimatrix(res, base)</span><br><span class="line">            power = power&gt;&gt;<span class="number">1</span></span><br><span class="line">            base = self.multimatrix(base, base)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">multimatrix</span><span class="params">(self, m1, m2)</span>:</span></span><br><span class="line">        n = len(m1)</span><br><span class="line">        res = [[<span class="number">0</span>]*n <span class="keyword">for</span> i <span class="keyword">in</span> range(n)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">                <span class="keyword">for</span> k <span class="keyword">in</span> range(n):</span><br><span class="line">                    res[i][j] = (res[i][j]+m1[i][k] * m2[k][j])%GLOBAL_MOD</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">ans = Solution()</span><br><span class="line">print((ans.fib(k+<span class="number">3</span>)))</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;链接：&lt;a href=&quot;https://ac.nowcoder.com/acm/problem/18987&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://ac.nowcoder.com/acm/problem/18987&lt;/a&gt;&lt;br&gt;来源：牛客网&lt;/p&gt;&lt;p&gt;时间限制：C/C++ 1秒，其他语言2秒&lt;br&gt;空间限制：C/C++ 32768K，其他语言65536K&lt;br&gt;64bit IO Format: %lld&lt;/p&gt;&lt;p&gt;&lt;strong&gt;题目描述&lt;/strong&gt; &lt;/p&gt;&lt;p&gt;qn是个特别可爱的小哥哥，qy是个特别好的小姐姐，他们两个是一对好朋友 [ cp (划掉~)&lt;br&gt;又是一年嘤花烂漫时，小qn于是就邀请了qy去嘤花盛开的地方去玩。当qy和qn来到了田野里时，qy惊奇的发现，嘤花花瓣以肉眼可见的速度从树上长了出来。&lt;br&gt;仔细看看的话，花瓣实际上是以一定规律长出来的，而且，每次张成新的花瓣的时候，上一次的花瓣就会都落到地上，而且不会消失。&lt;br&gt;花瓣生长的规律是，当次数大于等于2时，第i次长出来的花瓣个数和上一次张出来的花瓣个数的差是斐波那契数列的第i-1项。初始的时候地上没有花瓣，树上的花瓣个数为1，第一次生长的花瓣个数为1。初始的那个花瓣就落到了地上&lt;br&gt;现在，小qn想知道，经过k次生长之后，树上和地上的总花瓣个数是多少?&lt;br&gt;ps:斐波那契数列:&lt;br&gt;    f[1]=f[2]=1;f[i]=f[i-1]+f[i-2] (i&amp;gt;=2且i ∈  N+) &lt;/p&gt;
    
    </summary>
    
    
    
      <category term="NOWCODER" scheme="http://1979F.github.io/tags/NOWCODER/"/>
    
  </entry>
  
  <entry>
    <title>牛客15499 Jxc军训（快速幂、逆元）</title>
    <link href="http://1979F.github.io/2021/02/02/%E7%89%9B%E5%AE%A215499%20Jxc%E5%86%9B%E8%AE%AD%EF%BC%88%E5%BF%AB%E9%80%9F%E5%B9%82%EF%BC%8C%E9%80%86%E5%85%83%EF%BC%89/"/>
    <id>http://1979F.github.io/2021/02/02/牛客15499 Jxc军训（快速幂，逆元）/</id>
    <published>2021-02-02T03:27:30.000Z</published>
    <updated>2021-02-17T05:23:52.008Z</updated>
    
    <content type="html"><![CDATA[<p>链接：<a href="https://ac.nowcoder.com/acm/problem/15499" target="_blank" rel="noopener">https://ac.nowcoder.com/acm/problem/15499</a><br>来源：牛客网</p><p>时间限制：C/C++ 1秒，其他语言2秒<br>空间限制：C/C++ 262144K，其他语言524288K<br>64bit IO Format: %lld</p><p><strong>题目描述</strong> </p><p>在文某路学车中学高一新生军训中，Jxc正站在太阳下站着军姿，对于这样的酷热的阳光，Jxc 表示非常不爽。</p><a id="more"></a><p>Jxc将天空看做一个n*n的矩阵，此时天上有m朵云，这些云会随机分布在m个不同的位置，同时太阳会随机出现在一个位置，Jxc想知道他被太阳晒到的概率是多少，由于他仍在站军姿，所以这个有趣的问题就交给了你。考虑到精度问题，Jxc只需要知道这个概率在对998244353取模意义下的值。</p><p>Tips：一个分数p/q在模意义下的值即p*q-1在模意义下的值，Xp-1\equiv≡1 (mod p)</p><p><strong>输入描述:</strong></p><p>输入只有一行，包含两个整数n、m。n和m的意义见题面.</p><p><strong>输出描述:</strong></p><p>第一行包含一个整数Ans，为答案</p><p><img src="https://img-blog.csdnimg.cn/20210202112131942.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RzdW5kZXJlX3g=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>有关逆元的博客：<a href="https://www.cnblogs.com/linyujun/p/5194184.html" target="_blank" rel="noopener">https://www.cnblogs.com/linyujun/p/5194184.html</a></p><p>这道题里面，<br>p = (n* n-m)<br>q = n* n<br>ans = p/q = <code>p*q-1</code></p><p>题目提示了费马小定理</p><p>X^(a-1) ≡1 (mod a)</p><p>两边同除以X</p><p>X^(a-2) ≡1/X (mod a)</p><p>所以 1/X = X^(a-2)(mod a)</p><p>即 <code>q-1 = q^(a-2)(mod a)</code>，这里的a取 998244353，结果再乘上p即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">p = (n*n-m)</span></span><br><span class="line"><span class="string">q = n*n</span></span><br><span class="line"><span class="string">ans = p/q = p*q-1</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line">n, m = list(map(int, input().split()))</span><br><span class="line">mod = <span class="number">998244353</span></span><br><span class="line">ans = (n*n-m)*pow(n*n, mod<span class="number">-2</span>, mod)%mod</span><br><span class="line">print(ans)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;链接：&lt;a href=&quot;https://ac.nowcoder.com/acm/problem/15499&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://ac.nowcoder.com/acm/problem/15499&lt;/a&gt;&lt;br&gt;来源：牛客网&lt;/p&gt;&lt;p&gt;时间限制：C/C++ 1秒，其他语言2秒&lt;br&gt;空间限制：C/C++ 262144K，其他语言524288K&lt;br&gt;64bit IO Format: %lld&lt;/p&gt;&lt;p&gt;&lt;strong&gt;题目描述&lt;/strong&gt; &lt;/p&gt;&lt;p&gt;在文某路学车中学高一新生军训中，Jxc正站在太阳下站着军姿，对于这样的酷热的阳光，Jxc 表示非常不爽。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="NOWCODER" scheme="http://1979F.github.io/tags/NOWCODER/"/>
    
  </entry>
  
  <entry>
    <title>牛客14718 开心的涂刷</title>
    <link href="http://1979F.github.io/2021/02/02/%E7%89%9B%E5%AE%A214718%20%E5%BC%80%E5%BF%83%E7%9A%84%E6%B6%82%E5%88%B7/"/>
    <id>http://1979F.github.io/2021/02/02/牛客14718 开心的涂刷/</id>
    <published>2021-02-02T03:20:20.000Z</published>
    <updated>2021-02-17T05:23:01.746Z</updated>
    
    <content type="html"><![CDATA[<p>链接：<a href="https://ac.nowcoder.com/acm/problem/14718" target="_blank" rel="noopener">https://ac.nowcoder.com/acm/problem/14718</a><br>来源：牛客网</p><p>时间限制：C/C++ 1秒，其他语言2秒<br>空间限制：C/C++ 32768K，其他语言65536K<br>64bit IO Format: %lld</p><p><strong>题目描述</strong> </p><p>一天小明同学拿着m种颜色的油漆去涂刷n块格子，在涂刷的过程中他发现有很多种涂色方案，并很快的算出了答案，然后他发现如果涂好颜色的格子中只要存在某两个相邻的格子颜色一样，他就会感到开心，他想知道有多少种让他开心的涂刷方案。</p><a id="more"></a><p><strong>输入描述:</strong></p><p>输入仅包含一行，包含两个数n，m分别表示格子数和颜色数。（1 &lt;= n &lt;= 1e12, 1 &lt;= m &lt;= 1e12)</p><p><strong>输出描述:</strong></p><p>输出一行包含一个整数，让小明开心的涂刷方案数。 答案对1000000007取模</p><p><img src="https://img-blog.csdnimg.cn/20210202111929168.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RzdW5kZXJlX3g=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>一共有 mn个中所有的方案，我们只需要减去任意两个相邻的都不相同的即可，<br>  考虑第一位，可以染色的可能有m种，如果第一位染了m种其中一种颜色，<br>  那么第二位，只有m-1个选择，同理第三位，还是有m-1个选择，<br>  因为第一位的颜色还可以选,所以所有的可能应该为：mn−m∗(m−1)n−1,直接快速幂即可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">一共有 mn个中所有的方案，我们只需要减去任意两个相邻的都不相同的即可，</span></span><br><span class="line"><span class="string">  考虑第一位，可以染色的可能有m种，如果第一位染了m种其中一种颜色，</span></span><br><span class="line"><span class="string">  那么第二位，只有m-1个选择，同理第三位，还是有m-1个选择，</span></span><br><span class="line"><span class="string">  因为第一位的颜色还可以选,所以所有的可能应该为：mn−m∗(m−1)n−1,直接快速幂即可</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line">n, m = list(map(int, input().split()))</span><br><span class="line"></span><br><span class="line">MODULE = <span class="number">1000000007</span></span><br><span class="line">ans = pow(m, n, MODULE) - m * pow(m - <span class="number">1</span>, n - <span class="number">1</span>, MODULE)</span><br><span class="line">print(ans % MODULE)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;链接：&lt;a href=&quot;https://ac.nowcoder.com/acm/problem/14718&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://ac.nowcoder.com/acm/problem/14718&lt;/a&gt;&lt;br&gt;来源：牛客网&lt;/p&gt;&lt;p&gt;时间限制：C/C++ 1秒，其他语言2秒&lt;br&gt;空间限制：C/C++ 32768K，其他语言65536K&lt;br&gt;64bit IO Format: %lld&lt;/p&gt;&lt;p&gt;&lt;strong&gt;题目描述&lt;/strong&gt; &lt;/p&gt;&lt;p&gt;一天小明同学拿着m种颜色的油漆去涂刷n块格子，在涂刷的过程中他发现有很多种涂色方案，并很快的算出了答案，然后他发现如果涂好颜色的格子中只要存在某两个相邻的格子颜色一样，他就会感到开心，他想知道有多少种让他开心的涂刷方案。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="NOWCODER" scheme="http://1979F.github.io/tags/NOWCODER/"/>
    
  </entry>
  
  <entry>
    <title>牛客15187 分元宵（快速幂）</title>
    <link href="http://1979F.github.io/2021/02/02/%E7%89%9B%E5%AE%A215187%20%E5%88%86%E5%85%83%E5%AE%B5%20%EF%BC%88%E5%BF%AB%E9%80%9F%E5%B9%82%EF%BC%89/"/>
    <id>http://1979F.github.io/2021/02/02/牛客15187 分元宵 （快速幂）/</id>
    <published>2021-02-02T03:18:18.000Z</published>
    <updated>2021-02-17T05:22:18.433Z</updated>
    
    <content type="html"><![CDATA[<p>链接：<a href="https://ac.nowcoder.com/acm/problem/15187" target="_blank" rel="noopener">https://ac.nowcoder.com/acm/problem/15187</a><br>来源：牛客网</p><p>时间限制：C/C++ 1秒，其他语言2秒<br>空间限制：C/C++ 262144K，其他语言524288K<br>64bit IO Format: %lld</p><p><strong>题目描述</strong><br><img src="https://img-blog.csdnimg.cn/20210202111749811.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RzdW5kZXJlX3g=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s, v, w, p, A = list(map(int, input().split()))</span><br><span class="line">print(pow(s*v,w*p,A))</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;链接：&lt;a href=&quot;https://ac.nowcoder.com/acm/problem/15187&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://ac.nowcoder.com/acm/problem/15187&lt;/a&gt;&lt;br&gt;来源
      
    
    </summary>
    
    
    
      <category term="NOWCODER" scheme="http://1979F.github.io/tags/NOWCODER/"/>
    
  </entry>
  
  <entry>
    <title>牛客15324 用来作弊的药水</title>
    <link href="http://1979F.github.io/2021/02/02/%E7%89%9B%E5%AE%A215324%20%E7%94%A8%E6%9D%A5%E4%BD%9C%E5%BC%8A%E7%9A%84%E8%8D%AF%E6%B0%B4/"/>
    <id>http://1979F.github.io/2021/02/02/牛客15324 用来作弊的药水/</id>
    <published>2021-02-02T03:16:41.000Z</published>
    <updated>2021-02-17T05:21:24.638Z</updated>
    
    <content type="html"><![CDATA[<p>链接：<a href="https://ac.nowcoder.com/acm/problem/15324" target="_blank" rel="noopener">https://ac.nowcoder.com/acm/problem/15324</a><br>来源：牛客网</p><p>时间限制：C/C++ 1秒，其他语言2秒<br>空间限制：C/C++ 32768K，其他语言65536K<br>64bit IO Format: %lld</p><p><strong>题目描述</strong></p><p>   在一个风雨交加的夜晚，来自异世界的不愿透露姓名的TMK同学获得了两种超强药水A、B。根据说明书，TMK知道了这两种药水的作用：<br>    (1)药水A能使人的生命值提高，每饮用1个单位能使他生命值变成原来的x倍，即每饮用p个单位能使他的生命值变成原来的x^p(x的p次方)倍。<br>    (2)药水B能使人的能量值提高，每饮用1个单位能使他能量值变成原来的y倍，即每饮用q个单位能使他的能量值变成原来的y^q(y的q次方)倍。<br>    于是TMK迫不及待地喝下了所有的a个单位的药水A和b个单位的药水B，他立马体会到了自己能力的超强变化，然后他看了接下来的说明书：<br>    药水A和药水B能互相抑制对方的负面效果，一旦生命值提升的倍数和能量值提升的倍数不相等，那么在五个小时后将会发生非常严重的后果。<br>    于是TMK同学慌了，他想知道自己提升的生命值和能量值的倍数是否相等，由于他非常慌张，所以他把计算的重任交给你了。<br>作为埃森哲公司的一员，你觉得这个问题很简单，这得益于埃森哲公司分享知识的文化。</p><a id="more"></a><p>   分享知识已成为埃森哲源远流长的文化。<br>   埃森哲公司在帮助客户进行行之有效的知识管理的同时，它的管理层在其内部也进行了成功的知识管理的实践。如今，在埃森哲，分享知识已成为其源远流长的文化。在很大程度上，埃森哲公司的成功得益于其强大的知识管理系统。</p><p><strong>输入描述:</strong></p><p>第一行一个整数T，代表有T组数据。(1&lt;=T&lt;=5000)<br>每组数据仅一行，包含四个整数x,a,y,b，意义为题目描述。(1&lt;=x,a,y,b&lt;=10^9)</p><p><strong>输出描述:</strong></p><p>每组数据输出一行”Yes”或”No”(不包含双引号)，表示TMK提升的生命值和能量值的倍数是否相等，相等为”Yes”，不相等为”No”。</p><p><img src="https://img-blog.csdnimg.cn/20210202111618880.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RzdW5kZXJlX3g=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">T = int(input())</span><br><span class="line">mod = <span class="number">10000000007</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(T):</span><br><span class="line">    x, a, y, b = list(map(int, input().split()))</span><br><span class="line">    <span class="keyword">if</span> pow(x, a, mod) == pow(y, b, mod):</span><br><span class="line">        print(<span class="string">"Yes"</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">"No"</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;链接：&lt;a href=&quot;https://ac.nowcoder.com/acm/problem/15324&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://ac.nowcoder.com/acm/problem/15324&lt;/a&gt;&lt;br&gt;来源：牛客网&lt;/p&gt;&lt;p&gt;时间限制：C/C++ 1秒，其他语言2秒&lt;br&gt;空间限制：C/C++ 32768K，其他语言65536K&lt;br&gt;64bit IO Format: %lld&lt;/p&gt;&lt;p&gt;&lt;strong&gt;题目描述&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;   在一个风雨交加的夜晚，来自异世界的不愿透露姓名的TMK同学获得了两种超强药水A、B。根据说明书，TMK知道了这两种药水的作用：&lt;br&gt;    (1)药水A能使人的生命值提高，每饮用1个单位能使他生命值变成原来的x倍，即每饮用p个单位能使他的生命值变成原来的x^p(x的p次方)倍。&lt;br&gt;    (2)药水B能使人的能量值提高，每饮用1个单位能使他能量值变成原来的y倍，即每饮用q个单位能使他的能量值变成原来的y^q(y的q次方)倍。&lt;br&gt;    于是TMK迫不及待地喝下了所有的a个单位的药水A和b个单位的药水B，他立马体会到了自己能力的超强变化，然后他看了接下来的说明书：&lt;br&gt;    药水A和药水B能互相抑制对方的负面效果，一旦生命值提升的倍数和能量值提升的倍数不相等，那么在五个小时后将会发生非常严重的后果。&lt;br&gt;    于是TMK同学慌了，他想知道自己提升的生命值和能量值的倍数是否相等，由于他非常慌张，所以他把计算的重任交给你了。&lt;br&gt;作为埃森哲公司的一员，你觉得这个问题很简单，这得益于埃森哲公司分享知识的文化。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="NOWCODER" scheme="http://1979F.github.io/tags/NOWCODER/"/>
    
  </entry>
  
  <entry>
    <title>牛客18985 数字权重（数学、快速幂）</title>
    <link href="http://1979F.github.io/2021/02/02/%E7%89%9B%E5%AE%A218985%20%E6%95%B0%E5%AD%97%E6%9D%83%E9%87%8D%20%EF%BC%88%E6%95%B0%E5%AD%A6%EF%BC%8C%E5%BF%AB%E9%80%9F%E5%B9%82%EF%BC%89/"/>
    <id>http://1979F.github.io/2021/02/02/牛客18985 数字权重 （数学，快速幂）/</id>
    <published>2021-02-02T03:15:11.000Z</published>
    <updated>2021-02-17T05:22:29.885Z</updated>
    
    <content type="html"><![CDATA[<p>链接：<a href="https://ac.nowcoder.com/acm/problem/18985" target="_blank" rel="noopener">https://ac.nowcoder.com/acm/problem/18985</a><br>来源：牛客网</p><p>时间限制：C/C++ 1秒，其他语言2秒<br>空间限制：C/C++ 32768K，其他语言65536K<br>64bit IO Format: %lld</p><p><strong>题目描述</strong> </p><p>小a有一个n位的数字，但是它忘了各个位上的数是什么，现在请你来确定各个位上的数字，满足以下条件：<br><img src="https://img-blog.csdnimg.cn/20210202111353349.png" alt="在这里插入图片描述"></p><a id="more"></a><p>设第i位的数为ai，其中a1为最高位，an为最低位，K为给定的数字</p><p>请你求出满足条件的方案数</p><p><strong>输入描述:</strong></p><p>两个整数N, K<br>若存在无解的情况，请输出0</p><p><strong>输出描述:</strong></p><p>一个整数表示答案，对109 + 7取模</p><p><img src="https://img-blog.csdnimg.cn/2021020211141116.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RzdW5kZXJlX3g=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>不难通过条件二找到规律 an-a1 = K</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">K = an - a1</span></span><br><span class="line"><span class="string">所以只需要考虑首尾的方案数，然后中间n-2位的方案数就是10^(n-2)</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line">N, K = list(map(int, input().split()))</span><br><span class="line"></span><br><span class="line">MOD = <span class="number">1000000007</span></span><br><span class="line"><span class="keyword">if</span> <span class="number">0</span> &lt;= K &lt;= <span class="number">8</span>:</span><br><span class="line">    print(((<span class="number">9</span> - K) * pow(<span class="number">10</span>, N - <span class="number">2</span>, MOD)) % MOD)</span><br><span class="line"><span class="keyword">elif</span> <span class="number">-9</span> &lt;= K &lt;= <span class="number">-1</span>:</span><br><span class="line">    print(((<span class="number">10</span> + K) * pow(<span class="number">10</span>, N - <span class="number">2</span>, MOD)) % MOD)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;链接：&lt;a href=&quot;https://ac.nowcoder.com/acm/problem/18985&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://ac.nowcoder.com/acm/problem/18985&lt;/a&gt;&lt;br&gt;来源：牛客网&lt;/p&gt;&lt;p&gt;时间限制：C/C++ 1秒，其他语言2秒&lt;br&gt;空间限制：C/C++ 32768K，其他语言65536K&lt;br&gt;64bit IO Format: %lld&lt;/p&gt;&lt;p&gt;&lt;strong&gt;题目描述&lt;/strong&gt; &lt;/p&gt;&lt;p&gt;小a有一个n位的数字，但是它忘了各个位上的数是什么，现在请你来确定各个位上的数字，满足以下条件：&lt;br&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20210202111353349.png&quot; alt=&quot;在这里插入图片描述&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="NOWCODER" scheme="http://1979F.github.io/tags/NOWCODER/"/>
    
  </entry>
  
  <entry>
    <title>牛客19115 选择颜色</title>
    <link href="http://1979F.github.io/2021/02/02/%E7%89%9B%E5%AE%A219115%20%E9%80%89%E6%8B%A9%E9%A2%9C%E8%89%B2/"/>
    <id>http://1979F.github.io/2021/02/02/牛客19115 选择颜色/</id>
    <published>2021-02-02T03:12:26.000Z</published>
    <updated>2021-02-17T05:20:08.321Z</updated>
    
    <content type="html"><![CDATA[<p>链接：<a href="https://ac.nowcoder.com/acm/problem/19115" target="_blank" rel="noopener">https://ac.nowcoder.com/acm/problem/19115</a><br>来源：牛客网</p><p>时间限制：C/C++ 1秒，其他语言2秒<br>空间限制：C/C++ 32768K，其他语言65536K<br>64bit IO Format: %lld</p><p><strong>题目描述</strong> </p><p>n个人排成一个环形，每个人要从c种颜色中选择一个。<br>牛牛希望相邻的人选择的颜色是不同的<br>问有多少种方案。<br>输出方案数对10007取模的结果。<br>人是有顺序的，环旋转同构算不同的方案。</p><a id="more"></a><p><strong>输入描述:</strong></p><p>输入只有一行，包含用空格分开的两个整数，表示n和c。</p><p><strong>输出描述:</strong></p><p>输出一行一个整数，表示答案。</p><p><img src="https://img-blog.csdnimg.cn/20210202111158274.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RzdW5kZXJlX3g=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20210202111143687.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RzdW5kZXJlX3g=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>真的要好好学数学！！！</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">第一个人有c种选法， 与他相邻的人有c-1种选法，同理，剩下的人都是c-1</span></span><br><span class="line"><span class="string">这里有两种情况，第一种是第n个人的颜色和第一个人一样，第二种是不一样</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line">n, c = map(int, input().split())</span><br><span class="line"></span><br><span class="line">print(pow(c - <span class="number">1</span>, n, <span class="number">10007</span>)+(c<span class="number">-1</span>)*pow(<span class="number">-1</span>, n))</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;链接：&lt;a href=&quot;https://ac.nowcoder.com/acm/problem/19115&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://ac.nowcoder.com/acm/problem/19115&lt;/a&gt;&lt;br&gt;来源：牛客网&lt;/p&gt;&lt;p&gt;时间限制：C/C++ 1秒，其他语言2秒&lt;br&gt;空间限制：C/C++ 32768K，其他语言65536K&lt;br&gt;64bit IO Format: %lld&lt;/p&gt;&lt;p&gt;&lt;strong&gt;题目描述&lt;/strong&gt; &lt;/p&gt;&lt;p&gt;n个人排成一个环形，每个人要从c种颜色中选择一个。&lt;br&gt;牛牛希望相邻的人选择的颜色是不同的&lt;br&gt;问有多少种方案。&lt;br&gt;输出方案数对10007取模的结果。&lt;br&gt;人是有顺序的，环旋转同构算不同的方案。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="NOWCODER" scheme="http://1979F.github.io/tags/NOWCODER/"/>
    
  </entry>
  
  <entry>
    <title>牛客20701 神秘钥匙</title>
    <link href="http://1979F.github.io/2021/02/02/%E7%89%9B%E5%AE%A220701%20%E7%A5%9E%E7%A7%98%E9%92%A5%E5%8C%99/"/>
    <id>http://1979F.github.io/2021/02/02/牛客20701 神秘钥匙/</id>
    <published>2021-02-02T03:07:23.000Z</published>
    <updated>2021-02-17T05:19:36.933Z</updated>
    
    <content type="html"><![CDATA[<p>链接：<a href="https://ac.nowcoder.com/acm/problem/20701" target="_blank" rel="noopener">https://ac.nowcoder.com/acm/problem/20701</a><br>来源：牛客网</p><p>时间限制：C/C++ 1秒，其他语言2秒<br>空间限制：C/C++ 32768K，其他语言65536K<br>64bit IO Format: %lld</p><p><strong>题目描述</strong> </p><p>clccle一行𝑛个人来到了一个诡异的世界，她们需要去寻找逃出这个地方的方法——找到神秘的所罗门之匙<br>她们决定从中随机选出一些人去寻找钥匙，并在其中选出一个队长，clccle不想知道自己有多大几率被选中，她只想知道一共有多少种选择的方案 （选出的人数要在1−𝑛之间，不同的队长算不同的方案）。<br>方案数对1000000007取模 </p><a id="more"></a><p><strong>输入描述:</strong></p><p>第一行，一个整数𝑛。</p><p><strong>输出描述:</strong></p><p>一个整数，表示方案数。</p><p><img src="https://img-blog.csdnimg.cn/20210202110550659.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RzdW5kZXJlX3g=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>要用到一点点数学的推导式</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">n = int(input())</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">1Cn1 + 2Cn2 + …… +nCnn = n*2^(n-1)</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line">mod=<span class="number">1000000007</span></span><br><span class="line">print(n*pow(<span class="number">2</span>,n<span class="number">-1</span>,mod)%mod)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;链接：&lt;a href=&quot;https://ac.nowcoder.com/acm/problem/20701&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://ac.nowcoder.com/acm/problem/20701&lt;/a&gt;&lt;br&gt;来源：牛客网&lt;/p&gt;&lt;p&gt;时间限制：C/C++ 1秒，其他语言2秒&lt;br&gt;空间限制：C/C++ 32768K，其他语言65536K&lt;br&gt;64bit IO Format: %lld&lt;/p&gt;&lt;p&gt;&lt;strong&gt;题目描述&lt;/strong&gt; &lt;/p&gt;&lt;p&gt;clccle一行𝑛个人来到了一个诡异的世界，她们需要去寻找逃出这个地方的方法——找到神秘的所罗门之匙&lt;br&gt;她们决定从中随机选出一些人去寻找钥匙，并在其中选出一个队长，clccle不想知道自己有多大几率被选中，她只想知道一共有多少种选择的方案 （选出的人数要在1−𝑛之间，不同的队长算不同的方案）。&lt;br&gt;方案数对1000000007取模 &lt;/p&gt;
    
    </summary>
    
    
    
      <category term="NOWCODER" scheme="http://1979F.github.io/tags/NOWCODER/"/>
    
  </entry>
  
  <entry>
    <title>牛客13584 日历中的数字</title>
    <link href="http://1979F.github.io/2021/01/26/%E7%89%9B%E5%AE%A213584%20%E6%97%A5%E5%8E%86%E4%B8%AD%E7%9A%84%E6%95%B0%E5%AD%97/"/>
    <id>http://1979F.github.io/2021/01/26/牛客13584 日历中的数字/</id>
    <published>2021-01-26T09:40:15.000Z</published>
    <updated>2021-02-17T05:19:01.092Z</updated>
    
    <content type="html"><![CDATA[<p>链接：<a href="https://ac.nowcoder.com/acm/problem/13584" target="_blank" rel="noopener">https://ac.nowcoder.com/acm/problem/13584</a><br>来源：牛客网</p><p>时间限制：C/C++ 1秒，其他语言2秒<br>空间限制：C/C++ 131072K，其他语言262144K<br>64bit IO Format: %lld</p><p><strong>题目描述</strong> </p><p>ElemenT马上就要毕业了，他打开日历看了看时间。发现日历上的日期都是2017-04-04这样的格式的，月和日如果不足2位数，前面都会补充0。<br>给定一个年份和月份，ElemenT把那个月的日期都按上述格式写到纸上，他现在想知道某种数字出现了多少次。</p><a id="more"></a><p><strong>输入描述:</strong></p><p>多组输入<br>每组输入一行，有3个数字y,m,x(1000&lt;=y&lt;=3000,1&lt;=m&lt;=12,0&lt;=x&lt;=9)，分别代表年份，月份，和他想知道哪个数字出现的次数。</p><p><strong>输出描述:</strong></p><p>每组输出一个整数，表示数字x在这个月的日期里出现了多少次。</p><p><img src="https://img-blog.csdnimg.cn/20210126173933794.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RzdW5kZXJlX3g=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>注意闰年和月和日如果不足2位数，前面都会补充0即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fn</span><span class="params">(y)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> (y%<span class="number">4</span> ==<span class="number">0</span> <span class="keyword">and</span> y%<span class="number">100</span> !=<span class="number">0</span>) <span class="keyword">or</span> y%<span class="number">400</span> == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">c1 = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">10</span>, <span class="number">12</span>]</span><br><span class="line">c2 = [<span class="number">4</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">11</span>]</span><br><span class="line">c3 = [<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        y, m, x = list(map(int, input().split()))</span><br><span class="line">        <span class="keyword">if</span> m <span class="keyword">in</span> c1:</span><br><span class="line">            d = [<span class="number">12</span>, <span class="number">14</span>, <span class="number">13</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>]</span><br><span class="line">            n = <span class="number">31</span></span><br><span class="line">        <span class="keyword">elif</span> m <span class="keyword">in</span> c2:</span><br><span class="line">            d = [<span class="number">12</span>, <span class="number">13</span>, <span class="number">13</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>]</span><br><span class="line">            n = <span class="number">30</span></span><br><span class="line">        <span class="keyword">elif</span> m <span class="keyword">in</span> c3 <span class="keyword">and</span> fn(y):</span><br><span class="line">            d = [<span class="number">11</span>, <span class="number">13</span>, <span class="number">13</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>]</span><br><span class="line">            n = <span class="number">29</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            d = [<span class="number">11</span>, <span class="number">13</span>, <span class="number">12</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">2</span>]</span><br><span class="line">            n = <span class="number">28</span></span><br><span class="line">        <span class="keyword">if</span> m &lt;= <span class="number">9</span>:</span><br><span class="line">            d[<span class="number">0</span>] += n</span><br><span class="line">            d[m] += n</span><br><span class="line">        <span class="keyword">elif</span> m == <span class="number">10</span>:</span><br><span class="line">            d[<span class="number">1</span>] += n</span><br><span class="line">            d[<span class="number">0</span>] += n</span><br><span class="line">        <span class="keyword">elif</span> m == <span class="number">11</span>:</span><br><span class="line">            d[<span class="number">1</span>] += <span class="number">2</span>*n</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            d[<span class="number">1</span>] += n</span><br><span class="line">            d[<span class="number">2</span>] += n</span><br><span class="line">        res += d[x]</span><br><span class="line">        <span class="keyword">if</span> str(x) <span class="keyword">in</span> str(y):</span><br><span class="line">            res += (str(y).count(str(x)))*n</span><br><span class="line">        print(res)</span><br><span class="line">            </span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;链接：&lt;a href=&quot;https://ac.nowcoder.com/acm/problem/13584&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://ac.nowcoder.com/acm/problem/13584&lt;/a&gt;&lt;br&gt;来源：牛客网&lt;/p&gt;&lt;p&gt;时间限制：C/C++ 1秒，其他语言2秒&lt;br&gt;空间限制：C/C++ 131072K，其他语言262144K&lt;br&gt;64bit IO Format: %lld&lt;/p&gt;&lt;p&gt;&lt;strong&gt;题目描述&lt;/strong&gt; &lt;/p&gt;&lt;p&gt;ElemenT马上就要毕业了，他打开日历看了看时间。发现日历上的日期都是2017-04-04这样的格式的，月和日如果不足2位数，前面都会补充0。&lt;br&gt;给定一个年份和月份，ElemenT把那个月的日期都按上述格式写到纸上，他现在想知道某种数字出现了多少次。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="NOWCODER" scheme="http://1979F.github.io/tags/NOWCODER/"/>
    
  </entry>
  
  <entry>
    <title>牛客14386 水仙花数</title>
    <link href="http://1979F.github.io/2021/01/26/%E7%89%9B%E5%AE%A214386%20%E6%B0%B4%E4%BB%99%E8%8A%B1%E6%95%B0/"/>
    <id>http://1979F.github.io/2021/01/26/牛客14386 水仙花数/</id>
    <published>2021-01-26T09:38:32.000Z</published>
    <updated>2021-02-17T05:18:34.769Z</updated>
    
    <content type="html"><![CDATA[<p>链接：<a href="https://ac.nowcoder.com/acm/problem/14386" target="_blank" rel="noopener">https://ac.nowcoder.com/acm/problem/14386</a><br>来源：牛客网</p><p>时间限制：C/C++ 1秒，其他语言2秒<br>空间限制：C/C++ 32768K，其他语言65536K<br>64bit IO Format: %lld</p><p><strong>题目描述</strong> </p><p>水仙花数是指一个N位正整数（N≥3），它的每个位上的数字的N次幂之和等于它本身。<br>例如：153=1^3+5^3+3^3。<br>8208 = 8^4+2^4+0^4+8^4<br>这道题请写出程序判断输入的数是否为水仙花数</p><a id="more"></a><p><strong>输入描述:</strong></p><p>首先输入正整数 n，表示需要判断的数的个数 (1&lt;=n&lt;=100)<br>随后每一行输入一个数 Ai，对于每次输入判断 Ai 是否为水仙花数</p><p><strong>输出描述:</strong></p><p>每次判断 Ai 输出判断结果：<br>如果是，输出 yes<br>否则输出 no</p><p><img src="https://img-blog.csdnimg.cn/20210126173807918.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RzdW5kZXJlX3g=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">n = int(input())</span><br><span class="line">A = []</span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> range(n):</span><br><span class="line">    A.append(int(input()))</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fn</span><span class="params">(x)</span>:</span></span><br><span class="line">    s = str(x)</span><br><span class="line">    k = len(s)</span><br><span class="line">    ans = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(k):</span><br><span class="line">        ans += (int(s[i]))**k</span><br><span class="line">    <span class="keyword">if</span> ans == x:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">    <span class="keyword">if</span> fn(A[i]):</span><br><span class="line">        print(<span class="string">"yes"</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">"no"</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;链接：&lt;a href=&quot;https://ac.nowcoder.com/acm/problem/14386&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://ac.nowcoder.com/acm/problem/14386&lt;/a&gt;&lt;br&gt;来源：牛客网&lt;/p&gt;&lt;p&gt;时间限制：C/C++ 1秒，其他语言2秒&lt;br&gt;空间限制：C/C++ 32768K，其他语言65536K&lt;br&gt;64bit IO Format: %lld&lt;/p&gt;&lt;p&gt;&lt;strong&gt;题目描述&lt;/strong&gt; &lt;/p&gt;&lt;p&gt;水仙花数是指一个N位正整数（N≥3），它的每个位上的数字的N次幂之和等于它本身。&lt;br&gt;例如：153=1^3+5^3+3^3。&lt;br&gt;8208 = 8^4+2^4+0^4+8^4&lt;br&gt;这道题请写出程序判断输入的数是否为水仙花数&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="NOWCODER" scheme="http://1979F.github.io/tags/NOWCODER/"/>
    
  </entry>
  
</feed>
